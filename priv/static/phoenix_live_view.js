(function webpackUniversalModuleDefinition(root, factory) {
	if(typeof exports === 'object' && typeof module === 'object')
		module.exports = factory();
	else if(typeof define === 'function' && define.amd)
		define([], factory);
	else if(typeof exports === 'object')
		exports["phoenix_live_view"] = factory();
	else
		root["phoenix_live_view"] = factory();
})(this, function() {
return /******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, {
/******/ 				configurable: false,
/******/ 				enumerable: true,
/******/ 				get: getter
/******/ 			});
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function(exports) {
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = "./js/phoenix_live_view.js-exposed");
/******/ })
/************************************************************************/
/******/ ({

/***/ "./js/phoenix_live_view.js-exposed":
/*!*****************************************!*\
  !*** ./js/phoenix_live_view.js-exposed ***!
  \*****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("/* WEBPACK VAR INJECTION */(function(global) {if(!global[\"Phoenix\"]) global[\"Phoenix\"] = {};\nmodule.exports = global[\"Phoenix\"][\"LiveView\"] = __webpack_require__(/*! -!./node_modules/babel-loader/lib!./phoenix_live_view.js */ \"./node_modules/babel-loader/lib/index.js!./js/phoenix_live_view.js\");\n/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../node_modules/webpack/buildin/global.js */ \"./node_modules/webpack/buildin/global.js\")))\n\n//# sourceURL=webpack://phoenix_live_view/./js/phoenix_live_view.js-exposed?");

/***/ }),

/***/ "./node_modules/babel-loader/lib/index.js!./js/phoenix_live_view.js":
/*!*****************************************************************!*\
  !*** ./node_modules/babel-loader/lib!./js/phoenix_live_view.js ***!
  \*****************************************************************/
/*! exports provided: debug, Rendered, LiveSocket, Browser, DOM, View, default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"debug\", function() { return debug; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"Rendered\", function() { return Rendered; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"LiveSocket\", function() { return LiveSocket; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"Browser\", function() { return Browser; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"DOM\", function() { return DOM; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"View\", function() { return View; });\n/* harmony import */ var morphdom__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! morphdom */ \"./node_modules/morphdom/dist/morphdom-esm.js\");\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\nfunction _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _nonIterableRest(); }\n\nfunction _nonIterableRest() { throw new TypeError(\"Invalid attempt to destructure non-iterable instance\"); }\n\nfunction _iterableToArrayLimit(arr, i) { if (!(Symbol.iterator in Object(arr) || Object.prototype.toString.call(arr) === \"[object Arguments]\")) { return; } var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i[\"return\"] != null) _i[\"return\"](); } finally { if (_d) throw _e; } } return _arr; }\n\nfunction _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }\n\nfunction _typeof(obj) { if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return _typeof(obj); }\n\n/*\n================================================================================\nPhoenix LiveView JavaScript Client\n================================================================================\n\nSee the hexdocs at `https://hexdocs.pm/phoenix_live_view` for documentation.\n\n*/\n\nvar CLIENT_OUTDATED = \"outdated\";\nvar RELOAD_JITTER = [1000, 10000];\nvar PHX_VIEW = \"data-phx-view\";\nvar PHX_COMPONENT = \"data-phx-component\";\nvar PHX_LIVE_LINK = \"data-phx-live-link\";\nvar PHX_CONNECTED_CLASS = \"phx-connected\";\nvar PHX_LOADING_CLASS = \"phx-loading\";\nvar PHX_DISCONNECTED_CLASS = \"phx-disconnected\";\nvar PHX_CLICKED_CLASS = \"phx-clicked\";\nvar PHX_ERROR_CLASS = \"phx-error\";\nvar PHX_PARENT_ID = \"data-phx-parent-id\";\nvar PHX_VIEW_SELECTOR = \"[\".concat(PHX_VIEW, \"]\");\nvar PHX_ERROR_FOR = \"data-phx-error-for\";\nvar PHX_HAS_FOCUSED = \"phx-has-focused\";\nvar FOCUSABLE_INPUTS = [\"text\", \"textarea\", \"number\", \"email\", \"password\", \"search\", \"tel\", \"url\"];\nvar PHX_HAS_SUBMITTED = \"phx-has-submitted\";\nvar PHX_SESSION = \"data-phx-session\";\nvar PHX_STATIC = \"data-phx-static\";\nvar PHX_READONLY = \"data-phx-readonly\";\nvar PHX_DISABLED = \"data-phx-disabled\";\nvar PHX_DISABLE_WITH = \"disable-with\";\nvar PHX_HOOK = \"hook\";\nvar PHX_DEBOUNCE = \"debounce\";\nvar PHX_THROTTLE = \"throttle\";\nvar PHX_CHANGE = \"phx-change\";\nvar PHX_UPDATE = \"update\";\nvar PHX_PRIVATE = \"phxPrivate\";\nvar LOADER_TIMEOUT = 1;\nvar BEFORE_UNLOAD_LOADER_TIMEOUT = 200;\nvar BINDING_PREFIX = \"phx-\";\nvar PUSH_TIMEOUT = 30000;\nvar LINK_HEADER = \"x-requested-with\";\nvar DEBOUNCE_BLUR = \"debounce-blur\";\nvar DEBOUNCE_TIMER = \"debounce-timer\";\nvar DEBOUNCE_PREV_KEY = \"debounce-prev-key\";\n\nvar logError = function logError(msg, obj) {\n  return console.error && console.error(msg, obj);\n};\n\nvar debug = function debug(view, kind, msg, obj) {\n  console.log(\"\".concat(view.id, \" \").concat(kind, \": \").concat(msg, \" - \"), obj);\n}; // wraps value in closure or returns closure\n\nvar closure = function closure(val) {\n  return typeof val === \"function\" ? val : function () {\n    return val;\n  };\n};\n\nvar clone = function clone(obj) {\n  return JSON.parse(JSON.stringify(obj));\n};\n\nvar closestPhxBinding = function closestPhxBinding(el, binding) {\n  do {\n    if (el.matches(\"[\".concat(binding, \"]\"))) {\n      return el;\n    }\n\n    el = el.parentElement || el.parentNode;\n  } while (el !== null && el.nodeType === 1 && !el.matches(PHX_VIEW_SELECTOR));\n\n  return null;\n};\n\nvar isObject = function isObject(obj) {\n  return obj !== null && _typeof(obj) === \"object\" && !(obj instanceof Array);\n};\n\nvar isEmpty = function isEmpty(obj) {\n  for (var x in obj) {\n    return false;\n  }\n\n  return true;\n};\n\nvar maybe = function maybe(el, callback) {\n  return el && callback(el);\n};\n\nvar serializeForm = function serializeForm(form) {\n  var meta = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  var formData = new FormData(form);\n  var params = new URLSearchParams();\n  var _iteratorNormalCompletion = true;\n  var _didIteratorError = false;\n  var _iteratorError = undefined;\n\n  try {\n    for (var _iterator = formData.entries()[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n      var _step$value = _slicedToArray(_step.value, 2),\n          key = _step$value[0],\n          val = _step$value[1];\n\n      params.append(key, val);\n    }\n  } catch (err) {\n    _didIteratorError = true;\n    _iteratorError = err;\n  } finally {\n    try {\n      if (!_iteratorNormalCompletion && _iterator[\"return\"] != null) {\n        _iterator[\"return\"]();\n      }\n    } finally {\n      if (_didIteratorError) {\n        throw _iteratorError;\n      }\n    }\n  }\n\n  for (var metaKey in meta) {\n    params.append(metaKey, meta[metaKey]);\n  }\n\n  return params.toString();\n};\n\nvar recursiveMerge = function recursiveMerge(target, source) {\n  for (var key in source) {\n    var val = source[key];\n    var targetVal = target[key];\n\n    if (isObject(val) && isObject(targetVal)) {\n      if (targetVal.dynamics && !val.dynamics) {\n        delete targetVal.dynamics;\n      }\n\n      recursiveMerge(targetVal, val);\n    } else {\n      target[key] = val;\n    }\n  }\n};\n\nvar Rendered = {\n  mergeDiff: function mergeDiff(source, diff) {\n    if (this.isNewFingerprint(diff)) {\n      return diff;\n    } else {\n      recursiveMerge(source, diff);\n      return source;\n    }\n  },\n  isNewFingerprint: function isNewFingerprint() {\n    var diff = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    return !!diff[\"static\"];\n  },\n  toString: function toString(rendered) {\n    var output = {\n      buffer: \"\"\n    };\n    this.toOutputBuffer(rendered, output);\n    return output.buffer;\n  },\n  toOutputBuffer: function toOutputBuffer(rendered, output) {\n    if (rendered.dynamics) {\n      return this.comprehensionToBuffer(rendered, output);\n    }\n\n    var statics = rendered[\"static\"];\n    output.buffer += statics[0];\n\n    for (var i = 1; i < statics.length; i++) {\n      this.dynamicToBuffer(rendered[i - 1], output);\n      output.buffer += statics[i];\n    }\n  },\n  comprehensionToBuffer: function comprehensionToBuffer(rendered, output) {\n    var dynamics = rendered.dynamics,\n        statics = rendered[\"static\"];\n\n    for (var d = 0; d < dynamics.length; d++) {\n      var dynamic = dynamics[d];\n      output.buffer += statics[0];\n\n      for (var i = 1; i < statics.length; i++) {\n        this.dynamicToBuffer(dynamic[i - 1], output);\n        output.buffer += statics[i];\n      }\n    }\n  },\n  dynamicToBuffer: function dynamicToBuffer(rendered, output) {\n    if (isObject(rendered)) {\n      this.toOutputBuffer(rendered, output);\n    } else {\n      output.buffer += rendered;\n    }\n  }\n};\n/** Initializes the LiveSocket\n *\n *\n * @param {string} endPoint - The string WebSocket endpoint, ie, `\"wss://example.com/live\"`,\n *                                               `\"/live\"` (inherited host & protocol)\n * @param {Phoenix.Socket} socket - the required Phoenix Socket class imported from \"phoenix\". For example:\n *\n *     import {Socket} from \"phoenix\"\n *     import {LiveSocket} from \"phoenix_live_view\"\n *     let liveSocket = new LiveSocket(\"/live\", Socket, {...})\n *\n * @param {Object} [opts] - Optional configuration. Outside of keys listed below, all\n * configuration is passed directly to the Phoenix Socket constructor.\n * @param {Function} [opts.params] - The optional function for passing connect params.\n * The function receives the viewName associated with a given LiveView. For example:\n *\n *     (viewName) => {view: viewName, token: window.myToken}\n *\n * @param {string} [opts.bindingPrefix] - The optional prefix to use for all phx DOM annotations.\n * Defaults to \"phx-\".\n * @param {string} [opts.hooks] - The optional object for referencing LiveView hook callbacks.\n * @param {Function} [opts.viewLogger] - The optional function to log debug information. For example:\n *\n *     (view, kind, msg, obj) => console.log(`${view.id} ${kind}: ${msg} - `, obj)\n*/\n\nvar LiveSocket =\n/*#__PURE__*/\nfunction () {\n  function LiveSocket(url, phxSocket) {\n    var _this = this;\n\n    var opts = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n\n    _classCallCheck(this, LiveSocket);\n\n    this.unloaded = false;\n\n    if (!phxSocket || phxSocket.constructor.name === \"Object\") {\n      throw new Error(\"\\n      a phoenix Socket must be provided as the second argument to the LiveSocket constructor. For example:\\n\\n          import {Socket} from \\\"phoenix\\\"\\n          import {LiveSocket} from \\\"phoenix_live_view\\\"\\n          let liveSocket = new LiveSocket(\\\"/live\\\", Socket, {...})\\n      \");\n    }\n\n    this.socket = new phxSocket(url, opts);\n    this.bindingPrefix = opts.bindingPrefix || BINDING_PREFIX;\n    this.opts = opts;\n    this.views = {};\n    this.params = closure(opts.params || {});\n    this.viewLogger = opts.viewLogger;\n    this.activeElement = null;\n    this.prevActive = null;\n    this.prevInput = null;\n    this.prevValue = null;\n    this.silenced = false;\n    this.root = null;\n    this.linkRef = 0;\n    this.href = window.location.href;\n    this.pendingLink = null;\n    this.currentLocation = clone(window.location);\n    this.hooks = opts.hooks || {};\n    this.socket.onOpen(function () {\n      if (_this.isUnloaded()) {\n        _this.destroyAllViews();\n\n        _this.joinRootViews();\n      }\n\n      _this.unloaded = false;\n    });\n    window.addEventListener(\"beforeunload\", function (e) {\n      _this.unloaded = true;\n    });\n    this.bindTopLevelEvents();\n  }\n\n  _createClass(LiveSocket, [{\n    key: \"getSocket\",\n    value: function getSocket() {\n      return this.socket;\n    }\n  }, {\n    key: \"log\",\n    value: function log(view, kind, msgCallback) {\n      if (this.viewLogger) {\n        var _msgCallback = msgCallback(),\n            _msgCallback2 = _slicedToArray(_msgCallback, 2),\n            msg = _msgCallback2[0],\n            obj = _msgCallback2[1];\n\n        this.viewLogger(view, kind, msg, obj);\n      }\n    }\n  }, {\n    key: \"connect\",\n    value: function connect() {\n      var _this2 = this;\n\n      if ([\"complete\", \"loaded\", \"interactive\"].indexOf(document.readyState) >= 0) {\n        this.joinRootViews();\n      } else {\n        document.addEventListener(\"DOMContentLoaded\", function () {\n          _this2.joinRootViews();\n        });\n      }\n\n      return this.socket.connect();\n    }\n  }, {\n    key: \"disconnect\",\n    value: function disconnect() {\n      this.socket.disconnect();\n    } // private\n\n  }, {\n    key: \"reloadWithJitter\",\n    value: function reloadWithJitter() {\n      this.disconnect();\n      var minMs = RELOAD_JITTER[0],\n          maxMs = RELOAD_JITTER[1];\n      var afterMs = Math.floor(Math.random() * (maxMs - minMs + 1)) + minMs;\n      setTimeout(function () {\n        return window.location.reload();\n      }, afterMs);\n    }\n  }, {\n    key: \"getHookCallbacks\",\n    value: function getHookCallbacks(hookName) {\n      return this.hooks[hookName];\n    }\n  }, {\n    key: \"isUnloaded\",\n    value: function isUnloaded() {\n      return this.unloaded;\n    }\n  }, {\n    key: \"getBindingPrefix\",\n    value: function getBindingPrefix() {\n      return this.bindingPrefix;\n    }\n  }, {\n    key: \"binding\",\n    value: function binding(kind) {\n      return \"\".concat(this.getBindingPrefix()).concat(kind);\n    }\n  }, {\n    key: \"channel\",\n    value: function channel(topic, params) {\n      return this.socket.channel(topic, params);\n    }\n  }, {\n    key: \"joinRootViews\",\n    value: function joinRootViews() {\n      var _this3 = this;\n\n      DOM.all(document, \"\".concat(PHX_VIEW_SELECTOR, \":not([\").concat(PHX_PARENT_ID, \"])\"), function (rootEl) {\n        var view = _this3.joinView(rootEl, null, _this3.getHref());\n\n        _this3.root = _this3.root || view;\n      });\n    }\n  }, {\n    key: \"replaceRoot\",\n    value: function replaceRoot(href) {\n      var _this4 = this;\n\n      var callback = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n      var linkRef = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : this.setPendingLink(href);\n      this.root.showLoader(LOADER_TIMEOUT);\n      var rootEl = this.root.el;\n      var rootID = this.root.id;\n      var wasLoading = this.root.isLoading();\n      Browser.fetchPage(href, function (status, html) {\n        if (status !== 200) {\n          return Browser.redirect(href);\n        }\n\n        var div = document.createElement(\"div\");\n        div.innerHTML = html;\n\n        _this4.joinView(div.firstChild, null, href, function (newRoot) {\n          if (!_this4.commitPendingLink(linkRef)) {\n            newRoot.destroy();\n            return;\n          }\n\n          callback && callback();\n\n          _this4.destroyViewById(rootID);\n\n          rootEl.replaceWith(newRoot.el);\n          _this4.root = newRoot;\n\n          if (wasLoading) {\n            _this4.root.showLoader();\n          }\n        });\n      });\n    }\n  }, {\n    key: \"joinView\",\n    value: function joinView(el, parentView, href, callback) {\n      if (this.getViewByEl(el)) {\n        return;\n      }\n\n      var view = new View(el, this, parentView, href);\n      this.views[view.id] = view;\n      view.join(callback);\n      return view;\n    }\n  }, {\n    key: \"owner\",\n    value: function owner(childEl, callback) {\n      var _this5 = this;\n\n      var view = maybe(childEl.closest(PHX_VIEW_SELECTOR), function (el) {\n        return _this5.getViewByEl(el);\n      });\n\n      if (view) {\n        callback(view);\n      }\n    }\n  }, {\n    key: \"getViewByEl\",\n    value: function getViewByEl(el) {\n      return this.views[el.id];\n    }\n  }, {\n    key: \"onViewError\",\n    value: function onViewError(view) {\n      this.dropActiveElement(view);\n    }\n  }, {\n    key: \"destroyAllViews\",\n    value: function destroyAllViews() {\n      for (var id in this.views) {\n        this.destroyViewById(id);\n      }\n    }\n  }, {\n    key: \"destroyViewByEl\",\n    value: function destroyViewByEl(el) {\n      return this.destroyViewById(el.id);\n    }\n  }, {\n    key: \"destroyViewById\",\n    value: function destroyViewById(id) {\n      var view = this.views[id];\n\n      if (view) {\n        delete this.views[view.id];\n\n        if (this.root && view.id === this.root.id) {\n          this.root = null;\n        }\n\n        view.destroy();\n      }\n    }\n  }, {\n    key: \"setActiveElement\",\n    value: function setActiveElement(target) {\n      var _this6 = this;\n\n      if (this.activeElement === target) {\n        return;\n      }\n\n      this.activeElement = target;\n\n      var cancel = function cancel() {\n        if (target === _this6.activeElement) {\n          _this6.activeElement = null;\n        }\n\n        target.removeEventListener(\"mouseup\", _this6);\n        target.removeEventListener(\"touchend\", _this6);\n      };\n\n      target.addEventListener(\"mouseup\", cancel);\n      target.addEventListener(\"touchend\", cancel);\n    }\n  }, {\n    key: \"getActiveElement\",\n    value: function getActiveElement() {\n      if (document.activeElement === document.body) {\n        return this.activeElement || document.activeElement;\n      } else {\n        return document.activeElement;\n      }\n    }\n  }, {\n    key: \"dropActiveElement\",\n    value: function dropActiveElement(view) {\n      if (this.prevActive && view.ownsElement(this.prevActive)) {\n        this.prevActive = null;\n      }\n    }\n  }, {\n    key: \"restorePreviouslyActiveFocus\",\n    value: function restorePreviouslyActiveFocus() {\n      if (this.prevActive && this.prevActive !== document.body) {\n        this.prevActive.focus();\n      }\n    }\n  }, {\n    key: \"blurActiveElement\",\n    value: function blurActiveElement() {\n      this.prevActive = this.getActiveElement();\n\n      if (this.prevActive !== document.body) {\n        this.prevActive.blur();\n      }\n    }\n  }, {\n    key: \"bindTopLevelEvents\",\n    value: function bindTopLevelEvents() {\n      this.bindClicks();\n      this.bindNav();\n      this.bindForms();\n      this.bindTargetable({\n        keyup: \"keyup\",\n        keydown: \"keydown\"\n      }, function (e, type, view, target, phxEvent, phxTarget) {\n        view.pushKey(target, type, phxEvent, {\n          altGraphKey: e.altGraphKey,\n          altKey: e.altKey,\n          charCode: e.charCode,\n          code: e.code,\n          ctrlKey: e.ctrlKey,\n          key: e.key,\n          keyCode: e.keyCode,\n          keyIdentifier: e.keyIdentifier,\n          keyLocation: e.keyLocation,\n          location: e.location,\n          metaKey: e.metaKey,\n          repeat: e.repeat,\n          shiftKey: e.shiftKey,\n          which: e.which\n        });\n      });\n      this.bindTargetable({\n        blur: \"focusout\",\n        focus: \"focusin\"\n      }, function (e, type, view, targetEl, phxEvent, phxTarget) {\n        if (!phxTarget) {\n          view.pushEvent(type, targetEl, phxEvent, {\n            type: type\n          });\n        }\n      });\n      this.bindTargetable({\n        blur: \"blur\",\n        focus: \"focus\"\n      }, function (e, type, view, targetEl, phxEvent, phxTarget) {\n        // blur and focus are triggered on document and window. Discard one to avoid dups\n        if (phxTarget && !phxTarget !== \"window\") {\n          view.pushEvent(type, targetEl, phxEvent, {\n            type: e.type\n          });\n        }\n      });\n    }\n  }, {\n    key: \"setPendingLink\",\n    value: function setPendingLink(href) {\n      this.linkRef++;\n      var ref = this.linkRef;\n      this.pendingLink = href;\n      return this.linkRef;\n    }\n  }, {\n    key: \"commitPendingLink\",\n    value: function commitPendingLink(linkRef) {\n      if (this.linkRef !== linkRef) {\n        return false;\n      } else {\n        this.href = this.pendingLink;\n        this.pendingLink = null;\n        return true;\n      }\n    }\n  }, {\n    key: \"getHref\",\n    value: function getHref() {\n      return this.href;\n    }\n  }, {\n    key: \"hasPendingLink\",\n    value: function hasPendingLink() {\n      return !!this.pendingLink;\n    }\n  }, {\n    key: \"bindTargetable\",\n    value: function bindTargetable(events, callback) {\n      var _this7 = this;\n\n      var _loop = function _loop(event) {\n        var browserEventName = events[event];\n\n        _this7.on(browserEventName, function (e) {\n          var binding = _this7.binding(event);\n\n          var bindTarget = _this7.binding(\"target\");\n\n          var targetPhxEvent = e.target.getAttribute && e.target.getAttribute(binding);\n\n          if (targetPhxEvent && !e.target.getAttribute(bindTarget)) {\n            _this7.owner(e.target, function (view) {\n              _this7.debounce(e.target, e, function () {\n                return callback(e, event, view, e.target, targetPhxEvent, null);\n              });\n            });\n          } else {\n            DOM.all(document, \"[\".concat(binding, \"][\").concat(bindTarget, \"=window]\"), function (el) {\n              var phxEvent = el.getAttribute(binding);\n\n              _this7.owner(el, function (view) {\n                _this7.debounce(el, e, function () {\n                  return callback(e, event, view, el, phxEvent, \"window\");\n                });\n              });\n            });\n          }\n        });\n      };\n\n      for (var event in events) {\n        _loop(event);\n      }\n    }\n  }, {\n    key: \"bindClicks\",\n    value: function bindClicks() {\n      var _this8 = this;\n\n      window.addEventListener(\"click\", function (e) {\n        var click = _this8.binding(\"click\");\n\n        var target = closestPhxBinding(e.target, click);\n        var phxEvent = target && target.getAttribute(click);\n\n        if (!phxEvent) {\n          return;\n        }\n\n        e.stopPropagation();\n        var meta = {\n          altKey: e.altKey,\n          shiftKey: e.shiftKey,\n          ctrlKey: e.ctrlKey,\n          metaKey: e.metaKey,\n          x: e.x || e.clientX,\n          y: e.y || e.clientY,\n          pageX: e.pageX,\n          pageY: e.pageY,\n          screenX: e.screenX,\n          screenY: e.screenY\n        };\n\n        _this8.owner(target, function (view) {\n          _this8.debounce(target, e, function () {\n            var text = target.innerText;\n            target.classList.add(PHX_CLICKED_CLASS);\n            target.innerText = target.getAttribute(_this8.binding(PHX_DISABLE_WITH));\n            target.disabled = true;\n            view.pushEvent(\"click\", target, phxEvent, meta, function () {\n              target.classList.remove(PHX_CLICKED_CLASS);\n              target.innerText = text;\n              target.disabled = false;\n            });\n          });\n        });\n      }, false);\n    }\n  }, {\n    key: \"bindNav\",\n    value: function bindNav() {\n      var _this9 = this;\n\n      if (!Browser.canPushState()) {\n        return;\n      }\n\n      window.onpopstate = function (event) {\n        if (!_this9.registerNewLocation(window.location)) {\n          return;\n        }\n\n        var href = window.location.href;\n\n        if (_this9.root.isConnected()) {\n          _this9.root.pushInternalLink(href);\n        } else {\n          _this9.replaceRoot(href);\n        }\n      };\n\n      window.addEventListener(\"click\", function (e) {\n        var target = closestPhxBinding(e.target, PHX_LIVE_LINK);\n        var phxEvent = target && target.getAttribute(PHX_LIVE_LINK);\n\n        if (!phxEvent) {\n          return;\n        }\n\n        var href = target.href;\n        e.preventDefault();\n\n        _this9.root.pushInternalLink(href, function () {\n          Browser.pushState(phxEvent, {}, href);\n\n          _this9.registerNewLocation(window.location);\n        });\n      }, false);\n    }\n  }, {\n    key: \"registerNewLocation\",\n    value: function registerNewLocation(newLocation) {\n      var _this$currentLocation = this.currentLocation,\n          pathname = _this$currentLocation.pathname,\n          search = _this$currentLocation.search;\n\n      if (pathname + search === newLocation.pathname + newLocation.search) {\n        return false;\n      } else {\n        this.currentLocation = clone(newLocation);\n        return true;\n      }\n    }\n  }, {\n    key: \"bindForms\",\n    value: function bindForms() {\n      var _this10 = this;\n\n      this.on(\"submit\", function (e) {\n        var phxEvent = e.target.getAttribute(_this10.binding(\"submit\"));\n\n        if (!phxEvent) {\n          return;\n        }\n\n        e.preventDefault();\n        e.target.disabled = true;\n\n        _this10.owner(e.target, function (view) {\n          return view.submitForm(e.target, phxEvent);\n        });\n      }, false);\n\n      for (var _i2 = 0, _arr2 = [\"change\", \"input\"]; _i2 < _arr2.length; _i2++) {\n        var type = _arr2[_i2];\n        this.on(type, function (e) {\n          var input = e.target;\n          var phxEvent = input.form && input.form.getAttribute(_this10.binding(\"change\"));\n\n          if (!phxEvent) {\n            return;\n          }\n\n          var value = JSON.stringify(new FormData(input.form).getAll(input.name));\n\n          if (_this10.prevInput === input && _this10.prevValue === value) {\n            return;\n          }\n\n          if (input.type === \"number\" && input.validity && input.validity.badInput) {\n            return;\n          }\n\n          _this10.prevInput = input;\n          _this10.prevValue = value;\n\n          _this10.owner(input, function (view) {\n            if (DOM.isTextualInput(input)) {\n              DOM.putPrivate(input, PHX_HAS_FOCUSED, true);\n            } else {\n              _this10.setActiveElement(input);\n            }\n\n            _this10.debounce(input, e, function () {\n              return view.pushInput(input, phxEvent, e);\n            });\n          });\n        }, false);\n      }\n    }\n  }, {\n    key: \"debounce\",\n    value: function debounce(el, event, callback) {\n      DOM.debounce(el, event, this.binding(PHX_DEBOUNCE), this.binding(PHX_THROTTLE), callback);\n    }\n  }, {\n    key: \"silenceEvents\",\n    value: function silenceEvents(callback) {\n      this.silenced = true;\n      callback();\n      this.silenced = false;\n    }\n  }, {\n    key: \"on\",\n    value: function on(event, callback) {\n      var _this11 = this;\n\n      window.addEventListener(event, function (e) {\n        if (!_this11.silenced) {\n          callback(e);\n        }\n      });\n    }\n  }]);\n\n  return LiveSocket;\n}();\nvar Browser = {\n  canPushState: function canPushState() {\n    return typeof history.pushState !== \"undefined\";\n  },\n  fetchPage: function fetchPage(href, callback) {\n    var req = new XMLHttpRequest();\n    req.open(\"GET\", href, true);\n    req.timeout = PUSH_TIMEOUT;\n    req.setRequestHeader(\"content-type\", \"text/html\");\n    req.setRequestHeader(\"cache-control\", \"max-age=0, no-cache, no-store, must-revalidate, post-check=0, pre-check=0\");\n    req.setRequestHeader(LINK_HEADER, \"live-link\");\n\n    req.onerror = function () {\n      return callback(400);\n    };\n\n    req.ontimeout = function () {\n      return callback(504);\n    };\n\n    req.onreadystatechange = function () {\n      if (req.readyState !== 4) {\n        return;\n      }\n\n      if (req.getResponseHeader(LINK_HEADER) !== \"live-link\") {\n        return callback(400);\n      }\n\n      if (req.status !== 200) {\n        return callback(req.status);\n      }\n\n      callback(200, req.responseText);\n    };\n\n    req.send();\n  },\n  pushState: function pushState(kind, meta, to) {\n    if (this.canPushState()) {\n      if (to !== window.location.href) {\n        history[kind + \"State\"](meta, \"\", to);\n      }\n    } else {\n      this.redirect(to);\n    }\n  },\n  setCookie: function setCookie(name, value) {\n    document.cookie = \"\".concat(name, \"=\").concat(value);\n  },\n  getCookie: function getCookie(name) {\n    return document.cookie.replace(new RegExp(\"(?:(?:^|.*;s*)\".concat(name, \"s*=s*([^;]*).*$)|^.*$\")), \"$1\");\n  },\n  redirect: function redirect(toURL, flash) {\n    if (flash) {\n      Browser.setCookie(\"__phoenix_flash__\", flash + \"; max-age=60000; path=/\");\n    }\n\n    window.location = toURL;\n  }\n};\nvar DOM = {\n  all: function all(node, query, callback) {\n    return Array.from(node.querySelectorAll(query)).forEach(callback);\n  },\n  \"private\": function _private(el, key) {\n    return el[PHX_PRIVATE] && el[PHX_PRIVATE][key];\n  },\n  deletePrivate: function deletePrivate(el, key) {\n    el[PHX_PRIVATE] && delete el[PHX_PRIVATE][key];\n  },\n  putPrivate: function putPrivate(el, key, value) {\n    if (!el[PHX_PRIVATE]) {\n      el[PHX_PRIVATE] = {};\n    }\n\n    el[PHX_PRIVATE][key] = value;\n  },\n  copyPrivates: function copyPrivates(target, source) {\n    if (source[PHX_PRIVATE]) {\n      target[PHX_PRIVATE] = clone(source[PHX_PRIVATE]);\n    }\n  },\n  debounce: function debounce(el, event, phxDebounce, phxThrottle, callback) {\n    var _this12 = this;\n\n    var debounce = el.getAttribute(phxDebounce);\n    var throttle = el.getAttribute(phxThrottle);\n    var value = debounce || throttle;\n\n    switch (value) {\n      case null:\n        return callback();\n\n      case \"blur\":\n        if (this[\"private\"](el, DEBOUNCE_BLUR)) {\n          return;\n        }\n\n        el.addEventListener(\"blur\", function () {\n          return callback();\n        });\n        this.putPrivate(el, DEBOUNCE_BLUR, value);\n        return;\n\n      default:\n        var timeout = parseInt(value);\n\n        if (isNaN(timeout)) {\n          return logError(\"invalid throttle/debounce value: \".concat(value));\n        }\n\n        if (throttle && event.type === \"keydown\") {\n          var prevKey = this[\"private\"](el, DEBOUNCE_PREV_KEY);\n          this.putPrivate(el, DEBOUNCE_PREV_KEY, event.which);\n\n          if (prevKey !== event.which) {\n            return callback();\n          }\n        }\n\n        if (this[\"private\"](el, DEBOUNCE_TIMER)) {\n          return;\n        }\n\n        var clearTimer = function clearTimer(e) {\n          if (throttle && e.type === PHX_CHANGE && e.detail.triggeredBy.name === el.name) {\n            return;\n          }\n\n          clearTimeout(_this12[\"private\"](el, DEBOUNCE_TIMER));\n\n          _this12.deletePrivate(el, DEBOUNCE_TIMER);\n        };\n\n        this.putPrivate(el, DEBOUNCE_TIMER, setTimeout(function () {\n          if (el.form) {\n            el.form.removeEventListener(PHX_CHANGE, clearTimer);\n            el.form.removeEventListener(\"submit\", clearTimer);\n          }\n\n          _this12.deletePrivate(el, DEBOUNCE_TIMER);\n\n          if (!throttle) {\n            callback();\n          }\n        }, timeout));\n\n        if (el.form) {\n          el.form.addEventListener(PHX_CHANGE, clearTimer);\n          el.form.addEventListener(\"submit\", clearTimer);\n        }\n\n        if (throttle) {\n          callback();\n        }\n\n    }\n  },\n  disableForm: function disableForm(form, prefix) {\n    var disableWith = \"\".concat(prefix).concat(PHX_DISABLE_WITH);\n    form.classList.add(PHX_LOADING_CLASS);\n    DOM.all(form, \"[\".concat(disableWith, \"]\"), function (el) {\n      var value = el.getAttribute(disableWith);\n      el.setAttribute(\"\".concat(disableWith, \"-restore\"), el.innerText);\n      el.innerText = value;\n    });\n    DOM.all(form, \"button\", function (button) {\n      button.setAttribute(PHX_DISABLED, button.disabled);\n      button.disabled = true;\n    });\n    DOM.all(form, \"input\", function (input) {\n      input.setAttribute(PHX_READONLY, input.readOnly);\n      input.readOnly = true;\n    });\n  },\n  restoreDisabledForm: function restoreDisabledForm(form, prefix) {\n    var disableWith = \"\".concat(prefix).concat(PHX_DISABLE_WITH);\n    form.classList.remove(PHX_LOADING_CLASS);\n    DOM.all(form, \"[\".concat(disableWith, \"]\"), function (el) {\n      var value = el.getAttribute(\"\".concat(disableWith, \"-restore\"));\n\n      if (value) {\n        if (el.nodeName === \"INPUT\") {\n          el.value = value;\n        } else {\n          el.innerText = value;\n        }\n\n        el.removeAttribute(\"\".concat(disableWith, \"-restore\"));\n      }\n    });\n    DOM.all(form, \"button\", function (button) {\n      var prev = button.getAttribute(PHX_DISABLED);\n\n      if (prev) {\n        button.disabled = prev === \"true\";\n        button.removeAttribute(PHX_DISABLED);\n      }\n    });\n    DOM.all(form, \"input\", function (input) {\n      var prev = input.getAttribute(PHX_READONLY);\n\n      if (prev) {\n        input.readOnly = prev === \"true\";\n        input.removeAttribute(PHX_READONLY);\n      }\n    });\n  },\n  discardError: function discardError(container, el) {\n    var field = el.getAttribute && el.getAttribute(PHX_ERROR_FOR);\n\n    if (!field) {\n      return;\n    }\n\n    var input = container.querySelector(\"#\".concat(field));\n\n    if (field && !(this[\"private\"](input, PHX_HAS_FOCUSED) || this[\"private\"](input.form, PHX_HAS_SUBMITTED))) {\n      el.style.display = \"none\";\n    }\n  },\n  isPhxChild: function isPhxChild(node) {\n    return node.getAttribute && node.getAttribute(PHX_PARENT_ID);\n  },\n  patch: function patch(view, container, id, html) {\n    var changes = {\n      added: [],\n      updated: [],\n      discarded: [],\n      phxChildrenAdded: []\n    };\n    var focused = view.liveSocket.getActiveElement();\n\n    var _ref = focused && DOM.isTextualInput(focused) ? focused : {},\n        selectionStart = _ref.selectionStart,\n        selectionEnd = _ref.selectionEnd;\n\n    var phxUpdate = view.liveSocket.binding(PHX_UPDATE);\n    var diffContainer = this.buildDiffContainer(container, html, phxUpdate);\n    Object(morphdom__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(container, diffContainer.outerHTML, {\n      childrenOnly: true,\n      onBeforeNodeAdded: function onBeforeNodeAdded(el) {\n        //input handling\n        DOM.discardError(container, el);\n        return el;\n      },\n      onNodeAdded: function onNodeAdded(el) {\n        // nested view handling\n        if (DOM.isPhxChild(el) && view.ownsElement(el)) {\n          changes.phxChildrenAdded.push(el);\n        }\n\n        changes.added.push(el);\n      },\n      onNodeDiscarded: function onNodeDiscarded(el) {\n        changes.discarded.push(el);\n      },\n      onBeforeNodeDiscarded: function onBeforeNodeDiscarded(el) {\n        // nested view handling\n        if (DOM.isPhxChild(el)) {\n          view.liveSocket.destroyViewByEl(el);\n          return true;\n        }\n      },\n      onBeforeElUpdated: function onBeforeElUpdated(fromEl, toEl) {\n        if (fromEl.isEqualNode(toEl)) {\n          return false;\n        } // Skip subtree if both elems and children are equal\n\n\n        if (fromEl.getAttribute(phxUpdate) === \"ignore\") {\n          return false;\n        }\n\n        if (fromEl.type === \"number\" && fromEl.validity && fromEl.validity.badInput) {\n          return false;\n        } // nested view handling\n\n\n        if (DOM.isPhxChild(toEl)) {\n          var prevStatic = fromEl.getAttribute(PHX_STATIC);\n          DOM.mergeAttrs(fromEl, toEl);\n          fromEl.setAttribute(PHX_STATIC, prevStatic);\n          return false;\n        } // input handling\n\n\n        DOM.copyPrivates(toEl, fromEl);\n        DOM.discardError(container, toEl);\n\n        if (DOM.isTextualInput(fromEl) && fromEl === focused) {\n          DOM.mergeInputs(fromEl, toEl);\n          changes.updated.push({\n            fromEl: fromEl,\n            toEl: fromEl\n          });\n          return false;\n        } else {\n          changes.updated.push({\n            fromEl: fromEl,\n            toEl: toEl\n          });\n          return true;\n        }\n      }\n    });\n    view.liveSocket.silenceEvents(function () {\n      return DOM.restoreFocus(focused, selectionStart, selectionEnd);\n    });\n    DOM.dispatchEvent(document, \"phx:update\");\n    return changes;\n  },\n  dispatchEvent: function dispatchEvent(target, eventString) {\n    var detail = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n    var event = new CustomEvent(eventString, {\n      bubbles: true,\n      cancelable: true,\n      detail: detail\n    });\n    target.dispatchEvent(event);\n  },\n  cloneNode: function cloneNode(node, html) {\n    var cloned = node.cloneNode();\n    cloned.innerHTML = html || node.innerHTML;\n    return cloned;\n  },\n  // builds container for morphdom patch\n  // - precomputes append/prepend content in diff node to make it appear as if\n  //   the contents had been appended/prepended on full child node list\n  // - precomputes updates on existing child ids within a prepend/append child list\n  //   to allow existing nodes to be updated in place rather than reordered\n  buildDiffContainer: function buildDiffContainer(container, html, phxUpdate) {\n    var _this13 = this;\n\n    var diffContainer = this.cloneNode(container, html);\n\n    var elementsOnly = function elementsOnly(child) {\n      return child.nodeType === Node.ELEMENT_NODE;\n    };\n\n    var idsOnly = function idsOnly(child) {\n      return child.id || logError(\"append/prepend children require IDs, got: \", child);\n    };\n\n    DOM.all(diffContainer, \"[\".concat(phxUpdate, \"=append],[\").concat(phxUpdate, \"=prepend]\"), function (el) {\n      var id = el.id || logError(\"append/prepend requires an ID, got: \", el);\n      var existingInContainer = container.querySelector(\"#\".concat(id));\n\n      if (!existingInContainer) {\n        return;\n      }\n\n      var existing = _this13.cloneNode(existingInContainer);\n\n      var updateType = el.getAttribute(phxUpdate);\n      var newIds = Array.from(el.childNodes).filter(elementsOnly).map(idsOnly);\n      var existingIds = Array.from(existing.childNodes).filter(elementsOnly).map(idsOnly);\n\n      if (newIds.toString() !== existingIds.toString()) {\n        var dupIds = newIds.filter(function (id) {\n          return existingIds.indexOf(id) >= 0;\n        });\n        dupIds.forEach(function (id) {\n          var updatedEl = el.querySelector(\"#\".concat(id));\n          existing.querySelector(\"#\".concat(id)).replaceWith(updatedEl);\n        });\n        el.insertAdjacentHTML(updateType === \"append\" ? \"afterbegin\" : \"beforeend\", existing.innerHTML);\n      }\n    });\n    return diffContainer;\n  },\n  mergeAttrs: function mergeAttrs(target, source) {\n    var exclude = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : [];\n    var attrs = source.attributes;\n\n    for (var i = 0, length = attrs.length; i < length; i++) {\n      var name = attrs[i].name;\n\n      if (exclude.indexOf(name) < 0) {\n        target.setAttribute(name, source.getAttribute(name));\n      }\n    }\n  },\n  mergeInputs: function mergeInputs(target, source) {\n    DOM.mergeAttrs(target, source, [\"value\"]);\n    target.readOnly = source.readOnly;\n  },\n  restoreFocus: function restoreFocus(focused, selectionStart, selectionEnd) {\n    if (!DOM.isTextualInput(focused)) {\n      return;\n    }\n\n    if (focused.value === \"\" || focused.readOnly) {\n      focused.blur();\n    }\n\n    focused.focus();\n\n    if (focused.setSelectionRange && focused.type === \"text\" || focused.type === \"textarea\") {\n      focused.setSelectionRange(selectionStart, selectionEnd);\n    }\n  },\n  isTextualInput: function isTextualInput(el) {\n    return FOCUSABLE_INPUTS.indexOf(el.type) >= 0;\n  }\n};\nvar View =\n/*#__PURE__*/\nfunction () {\n  function View(el, liveSocket, parentView, href) {\n    var _this14 = this;\n\n    _classCallCheck(this, View);\n\n    this.liveSocket = liveSocket;\n    this.parent = parentView;\n    this.gracefullyClosed = false;\n    this.el = el;\n    this.id = this.el.id;\n    this.view = this.el.getAttribute(PHX_VIEW);\n    this.loaderTimer = null;\n    this.pendingDiffs = [];\n    this.href = href;\n    this.joinedOnce = false;\n    this.viewHooks = {};\n    this.channel = this.liveSocket.channel(\"lv:\".concat(this.id), function () {\n      return {\n        url: _this14.href || _this14.liveSocket.root.href,\n        params: _this14.liveSocket.params(_this14.view),\n        session: _this14.getSession(),\n        \"static\": _this14.getStatic()\n      };\n    });\n    this.showLoader(LOADER_TIMEOUT);\n    this.bindChannel();\n  }\n\n  _createClass(View, [{\n    key: \"isConnected\",\n    value: function isConnected() {\n      return this.channel.canPush();\n    }\n  }, {\n    key: \"getSession\",\n    value: function getSession() {\n      return this.el.getAttribute(PHX_SESSION);\n    }\n  }, {\n    key: \"getStatic\",\n    value: function getStatic() {\n      var val = this.el.getAttribute(PHX_STATIC);\n      return val === \"\" ? null : val;\n    }\n  }, {\n    key: \"destroy\",\n    value: function destroy() {\n      var _this15 = this;\n\n      var callback = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : function () {};\n      clearTimeout(this.loaderTimer);\n\n      var onFinished = function onFinished() {\n        callback();\n\n        for (var id in _this15.viewHooks) {\n          _this15.destroyHook(_this15.viewHooks[id]);\n        }\n      };\n\n      if (this.hasGracefullyClosed()) {\n        this.log(\"destroyed\", function () {\n          return [\"the server view has gracefully closed\"];\n        });\n        onFinished();\n      } else {\n        this.log(\"destroyed\", function () {\n          return [\"the child has been removed from the parent\"];\n        });\n        this.channel.leave().receive(\"ok\", onFinished).receive(\"error\", onFinished).receive(\"timeout\", onFinished);\n      }\n    }\n  }, {\n    key: \"setContainerClasses\",\n    value: function setContainerClasses() {\n      var _this$el$classList;\n\n      this.el.classList.remove(PHX_CONNECTED_CLASS, PHX_DISCONNECTED_CLASS, PHX_ERROR_CLASS);\n\n      (_this$el$classList = this.el.classList).add.apply(_this$el$classList, arguments);\n    }\n  }, {\n    key: \"isLoading\",\n    value: function isLoading() {\n      return this.el.classList.contains(PHX_DISCONNECTED_CLASS);\n    }\n  }, {\n    key: \"showLoader\",\n    value: function showLoader(timeout) {\n      var _this16 = this;\n\n      clearTimeout(this.loaderTimer);\n\n      if (timeout) {\n        this.loaderTimer = setTimeout(function () {\n          return _this16.showLoader();\n        }, timeout);\n      } else {\n        for (var id in this.viewHooks) {\n          this.viewHooks[id].__trigger__(\"disconnected\");\n        }\n\n        this.setContainerClasses(PHX_DISCONNECTED_CLASS);\n      }\n    }\n  }, {\n    key: \"hideLoader\",\n    value: function hideLoader() {\n      clearTimeout(this.loaderTimer);\n\n      for (var id in this.viewHooks) {\n        this.viewHooks[id].__trigger__(\"reconnected\");\n      }\n\n      this.setContainerClasses(PHX_CONNECTED_CLASS);\n    }\n  }, {\n    key: \"log\",\n    value: function log(kind, msgCallback) {\n      this.liveSocket.log(this, kind, msgCallback);\n    }\n  }, {\n    key: \"onJoin\",\n    value: function onJoin(_ref2) {\n      var rendered = _ref2.rendered,\n          live_redirect = _ref2.live_redirect;\n      this.log(\"join\", function () {\n        return [\"\", JSON.stringify(rendered)];\n      });\n      this.rendered = rendered;\n      this.hideLoader();\n      var changes = DOM.patch(this, this.el, this.id, Rendered.toString(this.rendered));\n      changes.added.push(this.el);\n      DOM.all(this.el, \"[\".concat(this.binding(PHX_HOOK), \"]\"), function (hookEl) {\n        return changes.added.push(hookEl);\n      });\n      this.triggerHooks(changes);\n      this.joinNewChildren();\n\n      if (live_redirect) {\n        var kind = live_redirect.kind,\n            to = live_redirect.to;\n        Browser.pushState(kind, {}, to);\n      }\n    }\n  }, {\n    key: \"joinNewChildren\",\n    value: function joinNewChildren() {\n      var _this17 = this;\n\n      DOM.all(document, \"\".concat(PHX_VIEW_SELECTOR, \"[\").concat(PHX_PARENT_ID, \"=\\\"\").concat(this.id, \"\\\"]\"), function (el) {\n        var child = _this17.liveSocket.getViewByEl(el);\n\n        if (!child) {\n          _this17.liveSocket.joinView(el, _this17);\n        }\n      });\n    }\n  }, {\n    key: \"update\",\n    value: function update(diff) {\n      if (isEmpty(diff)) {\n        return;\n      }\n\n      if (this.liveSocket.hasPendingLink()) {\n        return this.pendingDiffs.push(diff);\n      }\n\n      this.log(\"update\", function () {\n        return [\"\", JSON.stringify(diff)];\n      });\n      this.rendered = Rendered.mergeDiff(this.rendered, diff);\n      var html = Rendered.toString(this.rendered);\n      var changes = DOM.patch(this, this.el, this.id, html);\n\n      if (changes.phxChildrenAdded.length > 0) {\n        this.joinNewChildren();\n      }\n\n      this.triggerHooks(changes);\n    }\n  }, {\n    key: \"getHook\",\n    value: function getHook(el) {\n      return this.viewHooks[ViewHook.elementID(el)];\n    }\n  }, {\n    key: \"addHook\",\n    value: function addHook(el) {\n      if (ViewHook.elementID(el) || !el.getAttribute) {\n        return;\n      }\n\n      var callbacks = this.liveSocket.getHookCallbacks(el.getAttribute(this.binding(PHX_HOOK)));\n\n      if (callbacks && this.ownsElement(el)) {\n        var hook = new ViewHook(this, el, callbacks);\n        this.viewHooks[ViewHook.elementID(hook.el)] = hook;\n\n        hook.__trigger__(\"mounted\");\n      }\n    }\n  }, {\n    key: \"destroyHook\",\n    value: function destroyHook(hook) {\n      hook.__trigger__(\"destroyed\");\n\n      delete this.viewHooks[ViewHook.elementID(hook.el)];\n    }\n  }, {\n    key: \"triggerHooks\",\n    value: function triggerHooks(changes) {\n      var _this18 = this;\n\n      var destroyedCIDs = [];\n      changes.updated.push({\n        fromEl: this.el,\n        toEl: this.el\n      });\n      changes.added.forEach(function (el) {\n        return _this18.addHook(el);\n      });\n      changes.updated.forEach(function (_ref3) {\n        var fromEl = _ref3.fromEl,\n            toEl = _ref3.toEl;\n\n        var hook = _this18.getHook(fromEl);\n\n        var phxAttr = _this18.binding(PHX_HOOK);\n\n        if (hook && toEl.getAttribute && fromEl.getAttribute(phxAttr) === toEl.getAttribute(phxAttr)) {\n          hook.__trigger__(\"updated\");\n        } else if (hook) {\n          _this18.destroyHook(hook);\n\n          _this18.addHook(fromEl);\n        }\n      });\n      changes.discarded.forEach(function (el) {\n        var cid = _this18.componentID(el);\n\n        if (cid) {\n          destroyedCIDs.push(cid);\n        }\n\n        var hook = _this18.getHook(el);\n\n        hook && _this18.destroyHook(hook);\n      });\n\n      if (destroyedCIDs.length > 0) {\n        this.pushComponentsDestroyed(destroyedCIDs);\n      }\n    }\n  }, {\n    key: \"applyPendingUpdates\",\n    value: function applyPendingUpdates() {\n      var _this19 = this;\n\n      this.pendingDiffs.forEach(function (diff) {\n        return _this19.update(diff);\n      });\n      this.pendingDiffs = [];\n    }\n  }, {\n    key: \"bindChannel\",\n    value: function bindChannel() {\n      var _this20 = this;\n\n      this.channel.on(\"diff\", function (diff) {\n        return _this20.update(diff);\n      });\n      this.channel.on(\"redirect\", function (_ref4) {\n        var to = _ref4.to,\n            flash = _ref4.flash;\n        return _this20.onRedirect({\n          to: to,\n          flash: flash\n        });\n      });\n      this.channel.on(\"live_redirect\", function (_ref5) {\n        var to = _ref5.to,\n            kind = _ref5.kind;\n        return _this20.onLiveRedirect({\n          to: to,\n          kind: kind\n        });\n      });\n      this.channel.on(\"external_live_redirect\", function (_ref6) {\n        var to = _ref6.to,\n            kind = _ref6.kind;\n        return _this20.onExternalLiveRedirect({\n          to: to,\n          kind: kind\n        });\n      });\n      this.channel.on(\"session\", function (_ref7) {\n        var token = _ref7.token;\n        return _this20.el.setAttribute(PHX_SESSION, token);\n      });\n      this.channel.onError(function (reason) {\n        return _this20.onError(reason);\n      });\n      this.channel.onClose(function () {\n        return _this20.onGracefulClose();\n      });\n    }\n  }, {\n    key: \"onGracefulClose\",\n    value: function onGracefulClose() {\n      this.gracefullyClosed = true;\n      this.liveSocket.destroyViewById(this.id);\n    }\n  }, {\n    key: \"onExternalLiveRedirect\",\n    value: function onExternalLiveRedirect(_ref8) {\n      var _this21 = this;\n\n      var to = _ref8.to,\n          kind = _ref8.kind;\n      this.liveSocket.replaceRoot(to, function () {\n        Browser.pushState(kind, {}, to);\n\n        _this21.liveSocket.registerNewLocation(window.location);\n      });\n    }\n  }, {\n    key: \"onLiveRedirect\",\n    value: function onLiveRedirect(_ref9) {\n      var to = _ref9.to,\n          kind = _ref9.kind;\n      this.href = to;\n      Browser.pushState(kind, {}, to);\n    }\n  }, {\n    key: \"onRedirect\",\n    value: function onRedirect(_ref10) {\n      var to = _ref10.to,\n          flash = _ref10.flash;\n      Browser.redirect(to, flash);\n    }\n  }, {\n    key: \"hasGracefullyClosed\",\n    value: function hasGracefullyClosed() {\n      return this.gracefullyClosed;\n    }\n  }, {\n    key: \"join\",\n    value: function join(callback) {\n      var _this22 = this;\n\n      if (this.parent) {\n        this.parent.channel.onClose(function () {\n          return _this22.onGracefulClose();\n        });\n        this.parent.channel.onError(function () {\n          return _this22.liveSocket.destroyViewById(_this22.id);\n        });\n      }\n\n      this.channel.join().receive(\"ok\", function (data) {\n        if (!_this22.joinedOnce) {\n          callback && callback(_this22);\n        }\n\n        _this22.joinedOnce = true;\n\n        _this22.onJoin(data);\n      }).receive(\"error\", function (resp) {\n        return _this22.onJoinError(resp);\n      }).receive(\"timeout\", function () {\n        return _this22.onJoinError(\"timeout\");\n      });\n    }\n  }, {\n    key: \"onJoinError\",\n    value: function onJoinError(resp) {\n      if (resp.reason === CLIENT_OUTDATED) {\n        return this.liveSocket.reloadWithJitter();\n      }\n\n      if (resp.redirect || resp.external_live_redirect) {\n        this.channel.leave();\n      }\n\n      if (resp.redirect) {\n        return this.onRedirect(resp.redirect);\n      }\n\n      if (resp.external_live_redirect) {\n        return this.onExternalLiveRedirect(resp.external_live_redirect);\n      }\n\n      this.displayError();\n      this.log(\"error\", function () {\n        return [\"unable to join\", resp];\n      });\n    }\n  }, {\n    key: \"onError\",\n    value: function onError(reason) {\n      this.log(\"error\", function () {\n        return [\"view crashed\", reason];\n      });\n      this.liveSocket.onViewError(this);\n      document.activeElement.blur();\n\n      if (this.liveSocket.isUnloaded()) {\n        this.showLoader(BEFORE_UNLOAD_LOADER_TIMEOUT);\n      } else {\n        this.displayError();\n      }\n    }\n  }, {\n    key: \"displayError\",\n    value: function displayError() {\n      this.showLoader();\n      this.setContainerClasses(PHX_DISCONNECTED_CLASS, PHX_ERROR_CLASS);\n    }\n  }, {\n    key: \"pushWithReply\",\n    value: function pushWithReply(event, payload) {\n      var _this23 = this;\n\n      var onReply = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : function () {};\n      return this.channel.push(event, payload, PUSH_TIMEOUT).receive(\"ok\", function (resp) {\n        if (resp.diff) {\n          _this23.update(resp.diff);\n        }\n\n        if (resp.redirect) {\n          _this23.onRedirect(resp.redirect);\n        }\n\n        if (resp.live_redirect) {\n          _this23.onLiveRedirect(resp.live_redirect);\n        }\n\n        if (resp.external_live_redirect) {\n          _this23.onExternalLiveRedirect(resp.external_live_redirect);\n        }\n\n        onReply(resp);\n      });\n    }\n  }, {\n    key: \"componentID\",\n    value: function componentID(el) {\n      return el.getAttribute && el.getAttribute(PHX_COMPONENT) && el.id;\n    }\n  }, {\n    key: \"targetComponentID\",\n    value: function targetComponentID(target) {\n      var _this24 = this;\n\n      return maybe(target.closest(\"[\".concat(PHX_COMPONENT, \"]\")), function (el) {\n        return _this24.ownsElement(el) && _this24.componentID(el);\n      });\n    }\n  }, {\n    key: \"pushEvent\",\n    value: function pushEvent(type, el, phxEvent, meta, onReply) {\n      var prefix = this.binding(\"value-\");\n\n      for (var i = 0; i < el.attributes.length; i++) {\n        var name = el.attributes[i].name;\n\n        if (name.startsWith(prefix)) {\n          meta[name.replace(prefix, \"\")] = el.getAttribute(name);\n        }\n      }\n\n      if (el.value !== undefined) {\n        meta.value = el.value;\n      }\n\n      this.pushWithReply(\"event\", {\n        type: type,\n        event: phxEvent,\n        value: meta,\n        cid: this.targetComponentID(el) || undefined\n      }, onReply);\n    }\n  }, {\n    key: \"pushKey\",\n    value: function pushKey(keyElement, kind, phxEvent, meta) {\n      if (keyElement.value !== undefined) {\n        meta.value = keyElement.value;\n      }\n\n      this.pushWithReply(\"event\", {\n        type: kind,\n        event: phxEvent,\n        value: meta,\n        cid: this.targetComponentID(keyElement) || undefined\n      });\n    }\n  }, {\n    key: \"pushInput\",\n    value: function pushInput(inputEl, phxEvent, e) {\n      DOM.dispatchEvent(inputEl.form, PHX_CHANGE, {\n        triggeredBy: inputEl\n      });\n      this.pushWithReply(\"event\", {\n        type: \"form\",\n        event: phxEvent,\n        value: serializeForm(inputEl.form, {\n          _target: e.target.name\n        }),\n        cid: this.targetComponentID(inputEl) || undefined\n      });\n    }\n  }, {\n    key: \"pushFormSubmit\",\n    value: function pushFormSubmit(formEl, phxEvent, onReply) {\n      this.pushWithReply(\"event\", {\n        type: \"form\",\n        event: phxEvent,\n        value: serializeForm(formEl),\n        cid: this.targetComponentID(formEl) || undefined\n      }, onReply);\n    }\n  }, {\n    key: \"pushInternalLink\",\n    value: function pushInternalLink(href, callback) {\n      var _this25 = this;\n\n      if (!this.isLoading()) {\n        this.showLoader(LOADER_TIMEOUT);\n      }\n\n      var linkRef = this.liveSocket.setPendingLink(href);\n      this.pushWithReply(\"link\", {\n        url: href\n      }, function (resp) {\n        if (resp.link_redirect) {\n          _this25.liveSocket.replaceRoot(href, callback, linkRef);\n        } else if (_this25.liveSocket.commitPendingLink(linkRef)) {\n          _this25.href = href;\n\n          _this25.applyPendingUpdates();\n\n          _this25.hideLoader();\n\n          callback && callback();\n        }\n      }).receive(\"timeout\", function () {\n        return Browser.redirect(window.location.href);\n      });\n    }\n  }, {\n    key: \"pushComponentsDestroyed\",\n    value: function pushComponentsDestroyed(cids) {\n      this.pushWithReply(\"cids_destroyed\", {\n        cids: cids\n      });\n    }\n  }, {\n    key: \"ownsElement\",\n    value: function ownsElement(el) {\n      return el.getAttribute(PHX_PARENT_ID) === this.id || maybe(el.closest(PHX_VIEW_SELECTOR), function (node) {\n        return node.id;\n      }) === this.id;\n    }\n  }, {\n    key: \"submitForm\",\n    value: function submitForm(form, phxEvent) {\n      var _this26 = this;\n\n      var prefix = this.liveSocket.getBindingPrefix();\n      DOM.putPrivate(form, PHX_HAS_SUBMITTED, true);\n      DOM.disableForm(form, prefix);\n      this.liveSocket.blurActiveElement(this);\n      this.pushFormSubmit(form, phxEvent, function () {\n        DOM.restoreDisabledForm(form, prefix);\n\n        _this26.liveSocket.restorePreviouslyActiveFocus();\n      });\n    }\n  }, {\n    key: \"binding\",\n    value: function binding(kind) {\n      return this.liveSocket.binding(kind);\n    }\n  }]);\n\n  return View;\n}();\nvar viewHookID = 1;\n\nvar ViewHook =\n/*#__PURE__*/\nfunction () {\n  _createClass(ViewHook, null, [{\n    key: \"makeID\",\n    value: function makeID() {\n      return viewHookID++;\n    }\n  }, {\n    key: \"elementID\",\n    value: function elementID(el) {\n      return el.phxHookId;\n    }\n  }]);\n\n  function ViewHook(view, el, callbacks) {\n    _classCallCheck(this, ViewHook);\n\n    this.__view = view;\n    this.__callbacks = callbacks;\n    this.el = el;\n    this.viewName = view.view;\n    this.el.phxHookId = this.constructor.makeID();\n\n    for (var key in this.__callbacks) {\n      this[key] = this.__callbacks[key];\n    }\n  }\n\n  _createClass(ViewHook, [{\n    key: \"pushEvent\",\n    value: function pushEvent(event) {\n      var payload = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n      this.__view.pushWithReply(\"event\", {\n        type: \"hook\",\n        event: event,\n        value: payload\n      });\n    }\n  }, {\n    key: \"__trigger__\",\n    value: function __trigger__(kind) {\n      var callback = this.__callbacks[kind];\n      callback && callback.call(this);\n    }\n  }]);\n\n  return ViewHook;\n}();\n\n/* harmony default export */ __webpack_exports__[\"default\"] = (LiveSocket);\n\n//# sourceURL=webpack://phoenix_live_view/./js/phoenix_live_view.js?./node_modules/babel-loader/lib");

/***/ }),

/***/ "./node_modules/morphdom/dist/morphdom-esm.js":
/*!****************************************************!*\
  !*** ./node_modules/morphdom/dist/morphdom-esm.js ***!
  \****************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\nfunction morphAttrs(fromNode, toNode) {\n    var attrs = toNode.attributes;\n    var i;\n    var attr;\n    var attrName;\n    var attrNamespaceURI;\n    var attrValue;\n    var fromValue;\n\n    // update attributes on original DOM element\n    for (i = attrs.length - 1; i >= 0; --i) {\n        attr = attrs[i];\n        attrName = attr.name;\n        attrNamespaceURI = attr.namespaceURI;\n        attrValue = attr.value;\n\n        if (attrNamespaceURI) {\n            attrName = attr.localName || attrName;\n            fromValue = fromNode.getAttributeNS(attrNamespaceURI, attrName);\n\n            if (fromValue !== attrValue) {\n                fromNode.setAttributeNS(attrNamespaceURI, attrName, attrValue);\n            }\n        } else {\n            fromValue = fromNode.getAttribute(attrName);\n\n            if (fromValue !== attrValue) {\n                fromNode.setAttribute(attrName, attrValue);\n            }\n        }\n    }\n\n    // Remove any extra attributes found on the original DOM element that\n    // weren't found on the target element.\n    attrs = fromNode.attributes;\n\n    for (i = attrs.length - 1; i >= 0; --i) {\n        attr = attrs[i];\n        if (attr.specified !== false) {\n            attrName = attr.name;\n            attrNamespaceURI = attr.namespaceURI;\n\n            if (attrNamespaceURI) {\n                attrName = attr.localName || attrName;\n\n                if (!toNode.hasAttributeNS(attrNamespaceURI, attrName)) {\n                    fromNode.removeAttributeNS(attrNamespaceURI, attrName);\n                }\n            } else {\n                if (!toNode.hasAttribute(attrName)) {\n                    fromNode.removeAttribute(attrName);\n                }\n            }\n        }\n    }\n}\n\nvar range; // Create a range object for efficently rendering strings to elements.\nvar NS_XHTML = 'http://www.w3.org/1999/xhtml';\n\nvar doc = typeof document === 'undefined' ? undefined : document;\nvar HAS_TEMPLATE_SUPPORT = !!doc && 'content' in doc.createElement('template');\nvar HAS_RANGE_SUPPORT = !!doc && doc.createRange && 'createContextualFragment' in doc.createRange();\n\nfunction createFragmentFromTemplate(str) {\n    var template = doc.createElement('template');\n    template.innerHTML = str;\n    return template.content.childNodes[0];\n}\n\nfunction createFragmentFromRange(str) {\n    if (!range) {\n        range = doc.createRange();\n        range.selectNode(doc.body);\n    }\n\n    var fragment = range.createContextualFragment(str);\n    return fragment.childNodes[0];\n}\n\nfunction createFragmentFromWrap(str) {\n    var fragment = doc.createElement('body');\n    fragment.innerHTML = str;\n    return fragment.childNodes[0];\n}\n\n/**\n * This is about the same\n * var html = new DOMParser().parseFromString(str, 'text/html');\n * return html.body.firstChild;\n *\n * @method toElement\n * @param {String} str\n */\nfunction toElement(str) {\n    if (HAS_TEMPLATE_SUPPORT) {\n      // avoid restrictions on content for things like `<tr><th>Hi</th></tr>` which\n      // createContextualFragment doesn't support\n      // <template> support not available in IE\n      return createFragmentFromTemplate(str);\n    } else if (HAS_RANGE_SUPPORT) {\n      return createFragmentFromRange(str);\n    }\n\n    return createFragmentFromWrap(str);\n}\n\n/**\n * Returns true if two node's names are the same.\n *\n * NOTE: We don't bother checking `namespaceURI` because you will never find two HTML elements with the same\n *       nodeName and different namespace URIs.\n *\n * @param {Element} a\n * @param {Element} b The target element\n * @return {boolean}\n */\nfunction compareNodeNames(fromEl, toEl) {\n    var fromNodeName = fromEl.nodeName;\n    var toNodeName = toEl.nodeName;\n\n    if (fromNodeName === toNodeName) {\n        return true;\n    }\n\n    if (toEl.actualize &&\n        fromNodeName.charCodeAt(0) < 91 && /* from tag name is upper case */\n        toNodeName.charCodeAt(0) > 90 /* target tag name is lower case */) {\n        // If the target element is a virtual DOM node then we may need to normalize the tag name\n        // before comparing. Normal HTML elements that are in the \"http://www.w3.org/1999/xhtml\"\n        // are converted to upper case\n        return fromNodeName === toNodeName.toUpperCase();\n    } else {\n        return false;\n    }\n}\n\n/**\n * Create an element, optionally with a known namespace URI.\n *\n * @param {string} name the element name, e.g. 'div' or 'svg'\n * @param {string} [namespaceURI] the element's namespace URI, i.e. the value of\n * its `xmlns` attribute or its inferred namespace.\n *\n * @return {Element}\n */\nfunction createElementNS(name, namespaceURI) {\n    return !namespaceURI || namespaceURI === NS_XHTML ?\n        doc.createElement(name) :\n        doc.createElementNS(namespaceURI, name);\n}\n\n/**\n * Copies the children of one DOM element to another DOM element\n */\nfunction moveChildren(fromEl, toEl) {\n    var curChild = fromEl.firstChild;\n    while (curChild) {\n        var nextChild = curChild.nextSibling;\n        toEl.appendChild(curChild);\n        curChild = nextChild;\n    }\n    return toEl;\n}\n\nfunction syncBooleanAttrProp(fromEl, toEl, name) {\n    if (fromEl[name] !== toEl[name]) {\n        fromEl[name] = toEl[name];\n        if (fromEl[name]) {\n            fromEl.setAttribute(name, '');\n        } else {\n            fromEl.removeAttribute(name);\n        }\n    }\n}\n\nvar specialElHandlers = {\n    OPTION: function(fromEl, toEl) {\n        var parentNode = fromEl.parentNode;\n        if (parentNode) {\n            var parentName = parentNode.nodeName.toUpperCase();\n            if (parentName === 'OPTGROUP') {\n                parentNode = parentNode.parentNode;\n                parentName = parentNode && parentNode.nodeName.toUpperCase();\n            }\n            if (parentName === 'SELECT' && !parentNode.hasAttribute('multiple')) {\n                if (fromEl.hasAttribute('selected') && !toEl.selected) {\n                    // Workaround for MS Edge bug where the 'selected' attribute can only be\n                    // removed if set to a non-empty value:\n                    // https://developer.microsoft.com/en-us/microsoft-edge/platform/issues/12087679/\n                    fromEl.setAttribute('selected', 'selected');\n                    fromEl.removeAttribute('selected');\n                }\n                // We have to reset select element's selectedIndex to -1, otherwise setting\n                // fromEl.selected using the syncBooleanAttrProp below has no effect.\n                // The correct selectedIndex will be set in the SELECT special handler below.\n                parentNode.selectedIndex = -1;\n            }\n        }\n        syncBooleanAttrProp(fromEl, toEl, 'selected');\n    },\n    /**\n     * The \"value\" attribute is special for the <input> element since it sets\n     * the initial value. Changing the \"value\" attribute without changing the\n     * \"value\" property will have no effect since it is only used to the set the\n     * initial value.  Similar for the \"checked\" attribute, and \"disabled\".\n     */\n    INPUT: function(fromEl, toEl) {\n        syncBooleanAttrProp(fromEl, toEl, 'checked');\n        syncBooleanAttrProp(fromEl, toEl, 'disabled');\n\n        if (fromEl.value !== toEl.value) {\n            fromEl.value = toEl.value;\n        }\n\n        if (!toEl.hasAttribute('value')) {\n            fromEl.removeAttribute('value');\n        }\n    },\n\n    TEXTAREA: function(fromEl, toEl) {\n        var newValue = toEl.value;\n        if (fromEl.value !== newValue) {\n            fromEl.value = newValue;\n        }\n\n        var firstChild = fromEl.firstChild;\n        if (firstChild) {\n            // Needed for IE. Apparently IE sets the placeholder as the\n            // node value and vise versa. This ignores an empty update.\n            var oldValue = firstChild.nodeValue;\n\n            if (oldValue == newValue || (!newValue && oldValue == fromEl.placeholder)) {\n                return;\n            }\n\n            firstChild.nodeValue = newValue;\n        }\n    },\n    SELECT: function(fromEl, toEl) {\n        if (!toEl.hasAttribute('multiple')) {\n            var selectedIndex = -1;\n            var i = 0;\n            // We have to loop through children of fromEl, not toEl since nodes can be moved\n            // from toEl to fromEl directly when morphing.\n            // At the time this special handler is invoked, all children have already been morphed\n            // and appended to / removed from fromEl, so using fromEl here is safe and correct.\n            var curChild = fromEl.firstChild;\n            var optgroup;\n            var nodeName;\n            while(curChild) {\n                nodeName = curChild.nodeName && curChild.nodeName.toUpperCase();\n                if (nodeName === 'OPTGROUP') {\n                    optgroup = curChild;\n                    curChild = optgroup.firstChild;\n                } else {\n                    if (nodeName === 'OPTION') {\n                        if (curChild.hasAttribute('selected')) {\n                            selectedIndex = i;\n                            break;\n                        }\n                        i++;\n                    }\n                    curChild = curChild.nextSibling;\n                    if (!curChild && optgroup) {\n                        curChild = optgroup.nextSibling;\n                        optgroup = null;\n                    }\n                }\n            }\n\n            fromEl.selectedIndex = selectedIndex;\n        }\n    }\n};\n\nvar ELEMENT_NODE = 1;\nvar DOCUMENT_FRAGMENT_NODE = 11;\nvar TEXT_NODE = 3;\nvar COMMENT_NODE = 8;\n\nfunction noop() {}\n\nfunction defaultGetNodeKey(node) {\n    return node.id;\n}\n\nfunction morphdomFactory(morphAttrs) {\n\n    return function morphdom(fromNode, toNode, options) {\n        if (!options) {\n            options = {};\n        }\n\n        if (typeof toNode === 'string') {\n            if (fromNode.nodeName === '#document' || fromNode.nodeName === 'HTML') {\n                var toNodeHtml = toNode;\n                toNode = doc.createElement('html');\n                toNode.innerHTML = toNodeHtml;\n            } else {\n                toNode = toElement(toNode);\n            }\n        }\n\n        var getNodeKey = options.getNodeKey || defaultGetNodeKey;\n        var onBeforeNodeAdded = options.onBeforeNodeAdded || noop;\n        var onNodeAdded = options.onNodeAdded || noop;\n        var onBeforeElUpdated = options.onBeforeElUpdated || noop;\n        var onElUpdated = options.onElUpdated || noop;\n        var onBeforeNodeDiscarded = options.onBeforeNodeDiscarded || noop;\n        var onNodeDiscarded = options.onNodeDiscarded || noop;\n        var onBeforeElChildrenUpdated = options.onBeforeElChildrenUpdated || noop;\n        var childrenOnly = options.childrenOnly === true;\n\n        // This object is used as a lookup to quickly find all keyed elements in the original DOM tree.\n        var fromNodesLookup = {};\n        var keyedRemovalList;\n\n        function addKeyedRemoval(key) {\n            if (keyedRemovalList) {\n                keyedRemovalList.push(key);\n            } else {\n                keyedRemovalList = [key];\n            }\n        }\n\n        function walkDiscardedChildNodes(node, skipKeyedNodes) {\n            if (node.nodeType === ELEMENT_NODE) {\n                var curChild = node.firstChild;\n                while (curChild) {\n\n                    var key = undefined;\n\n                    if (skipKeyedNodes && (key = getNodeKey(curChild))) {\n                        // If we are skipping keyed nodes then we add the key\n                        // to a list so that it can be handled at the very end.\n                        addKeyedRemoval(key);\n                    } else {\n                        // Only report the node as discarded if it is not keyed. We do this because\n                        // at the end we loop through all keyed elements that were unmatched\n                        // and then discard them in one final pass.\n                        onNodeDiscarded(curChild);\n                        if (curChild.firstChild) {\n                            walkDiscardedChildNodes(curChild, skipKeyedNodes);\n                        }\n                    }\n\n                    curChild = curChild.nextSibling;\n                }\n            }\n        }\n\n        /**\n         * Removes a DOM node out of the original DOM\n         *\n         * @param  {Node} node The node to remove\n         * @param  {Node} parentNode The nodes parent\n         * @param  {Boolean} skipKeyedNodes If true then elements with keys will be skipped and not discarded.\n         * @return {undefined}\n         */\n        function removeNode(node, parentNode, skipKeyedNodes) {\n            if (onBeforeNodeDiscarded(node) === false) {\n                return;\n            }\n\n            if (parentNode) {\n                parentNode.removeChild(node);\n            }\n\n            onNodeDiscarded(node);\n            walkDiscardedChildNodes(node, skipKeyedNodes);\n        }\n\n        // // TreeWalker implementation is no faster, but keeping this around in case this changes in the future\n        // function indexTree(root) {\n        //     var treeWalker = document.createTreeWalker(\n        //         root,\n        //         NodeFilter.SHOW_ELEMENT);\n        //\n        //     var el;\n        //     while((el = treeWalker.nextNode())) {\n        //         var key = getNodeKey(el);\n        //         if (key) {\n        //             fromNodesLookup[key] = el;\n        //         }\n        //     }\n        // }\n\n        // // NodeIterator implementation is no faster, but keeping this around in case this changes in the future\n        //\n        // function indexTree(node) {\n        //     var nodeIterator = document.createNodeIterator(node, NodeFilter.SHOW_ELEMENT);\n        //     var el;\n        //     while((el = nodeIterator.nextNode())) {\n        //         var key = getNodeKey(el);\n        //         if (key) {\n        //             fromNodesLookup[key] = el;\n        //         }\n        //     }\n        // }\n\n        function indexTree(node) {\n            if (node.nodeType === ELEMENT_NODE || node.nodeType === DOCUMENT_FRAGMENT_NODE) {\n                var curChild = node.firstChild;\n                while (curChild) {\n                    var key = getNodeKey(curChild);\n                    if (key) {\n                        fromNodesLookup[key] = curChild;\n                    }\n\n                    // Walk recursively\n                    indexTree(curChild);\n\n                    curChild = curChild.nextSibling;\n                }\n            }\n        }\n\n        indexTree(fromNode);\n\n        function handleNodeAdded(el) {\n            onNodeAdded(el);\n\n            var curChild = el.firstChild;\n            while (curChild) {\n                var nextSibling = curChild.nextSibling;\n\n                var key = getNodeKey(curChild);\n                if (key) {\n                    var unmatchedFromEl = fromNodesLookup[key];\n                    if (unmatchedFromEl && compareNodeNames(curChild, unmatchedFromEl)) {\n                        curChild.parentNode.replaceChild(unmatchedFromEl, curChild);\n                        morphEl(unmatchedFromEl, curChild);\n                    }\n                }\n\n                handleNodeAdded(curChild);\n                curChild = nextSibling;\n            }\n        }\n\n        function cleanupFromEl(fromEl, curFromNodeChild, curFromNodeKey) {\n            // We have processed all of the \"to nodes\". If curFromNodeChild is\n            // non-null then we still have some from nodes left over that need\n            // to be removed\n            while (curFromNodeChild) {\n                var fromNextSibling = curFromNodeChild.nextSibling;\n                if ((curFromNodeKey = getNodeKey(curFromNodeChild))) {\n                    // Since the node is keyed it might be matched up later so we defer\n                    // the actual removal to later\n                    addKeyedRemoval(curFromNodeKey);\n                } else {\n                    // NOTE: we skip nested keyed nodes from being removed since there is\n                    //       still a chance they will be matched up later\n                    removeNode(curFromNodeChild, fromEl, true /* skip keyed nodes */);\n                }\n                curFromNodeChild = fromNextSibling;\n            }\n        }\n\n        function morphEl(fromEl, toEl, childrenOnly) {\n            var toElKey = getNodeKey(toEl);\n\n            if (toElKey) {\n                // If an element with an ID is being morphed then it will be in the final\n                // DOM so clear it out of the saved elements collection\n                delete fromNodesLookup[toElKey];\n            }\n\n            if (toNode.isSameNode && toNode.isSameNode(fromNode)) {\n                return;\n            }\n\n            if (!childrenOnly) {\n                // optional\n                if (onBeforeElUpdated(fromEl, toEl) === false) {\n                    return;\n                }\n\n                // update attributes on original DOM element first\n                morphAttrs(fromEl, toEl);\n                // optional\n                onElUpdated(fromEl);\n\n                if (onBeforeElChildrenUpdated(fromEl, toEl) === false) {\n                    return;\n                }\n            }\n            if (fromEl.nodeName !== 'TEXTAREA') {\n              morphChildren(fromEl, toEl);\n            } else {\n              specialElHandlers.TEXTAREA(fromEl, toEl);\n            }\n        }\n\n        function morphChildren(fromEl, toEl) {\n            var curToNodeChild = toEl.firstChild;\n            var curFromNodeChild = fromEl.firstChild;\n            var curToNodeKey;\n            var curFromNodeKey;\n\n            var fromNextSibling;\n            var toNextSibling;\n            var matchingFromEl;\n\n            // walk the children\n            outer: while (curToNodeChild) {\n                toNextSibling = curToNodeChild.nextSibling;\n                curToNodeKey = getNodeKey(curToNodeChild);\n\n                // walk the fromNode children all the way through\n                while (curFromNodeChild) {\n                    fromNextSibling = curFromNodeChild.nextSibling;\n\n                    if (curToNodeChild.isSameNode && curToNodeChild.isSameNode(curFromNodeChild)) {\n                        curToNodeChild = toNextSibling;\n                        curFromNodeChild = fromNextSibling;\n                        continue outer;\n                    }\n\n                    curFromNodeKey = getNodeKey(curFromNodeChild);\n\n                    var curFromNodeType = curFromNodeChild.nodeType;\n\n                    // this means if the curFromNodeChild doesnt have a match with the curToNodeChild\n                    var isCompatible = undefined;\n\n                    if (curFromNodeType === curToNodeChild.nodeType) {\n                        if (curFromNodeType === ELEMENT_NODE) {\n                            // Both nodes being compared are Element nodes\n\n                            if (curToNodeKey) {\n                                // The target node has a key so we want to match it up with the correct element\n                                // in the original DOM tree\n                                if (curToNodeKey !== curFromNodeKey) {\n                                    // The current element in the original DOM tree does not have a matching key so\n                                    // let's check our lookup to see if there is a matching element in the original\n                                    // DOM tree\n                                    if ((matchingFromEl = fromNodesLookup[curToNodeKey])) {\n                                        if (fromNextSibling === matchingFromEl) {\n                                            // Special case for single element removals. To avoid removing the original\n                                            // DOM node out of the tree (since that can break CSS transitions, etc.),\n                                            // we will instead discard the current node and wait until the next\n                                            // iteration to properly match up the keyed target element with its matching\n                                            // element in the original tree\n                                            isCompatible = false;\n                                        } else {\n                                            // We found a matching keyed element somewhere in the original DOM tree.\n                                            // Let's move the original DOM node into the current position and morph\n                                            // it.\n\n                                            // NOTE: We use insertBefore instead of replaceChild because we want to go through\n                                            // the `removeNode()` function for the node that is being discarded so that\n                                            // all lifecycle hooks are correctly invoked\n                                            fromEl.insertBefore(matchingFromEl, curFromNodeChild);\n\n                                            // fromNextSibling = curFromNodeChild.nextSibling;\n\n                                            if (curFromNodeKey) {\n                                                // Since the node is keyed it might be matched up later so we defer\n                                                // the actual removal to later\n                                                addKeyedRemoval(curFromNodeKey);\n                                            } else {\n                                                // NOTE: we skip nested keyed nodes from being removed since there is\n                                                //       still a chance they will be matched up later\n                                                removeNode(curFromNodeChild, fromEl, true /* skip keyed nodes */);\n                                            }\n\n                                            curFromNodeChild = matchingFromEl;\n                                        }\n                                    } else {\n                                        // The nodes are not compatible since the \"to\" node has a key and there\n                                        // is no matching keyed node in the source tree\n                                        isCompatible = false;\n                                    }\n                                }\n                            } else if (curFromNodeKey) {\n                                // The original has a key\n                                isCompatible = false;\n                            }\n\n                            isCompatible = isCompatible !== false && compareNodeNames(curFromNodeChild, curToNodeChild);\n                            if (isCompatible) {\n                                // We found compatible DOM elements so transform\n                                // the current \"from\" node to match the current\n                                // target DOM node.\n                                // MORPH\n                                morphEl(curFromNodeChild, curToNodeChild);\n                            }\n\n                        } else if (curFromNodeType === TEXT_NODE || curFromNodeType == COMMENT_NODE) {\n                            // Both nodes being compared are Text or Comment nodes\n                            isCompatible = true;\n                            // Simply update nodeValue on the original node to\n                            // change the text value\n                            if (curFromNodeChild.nodeValue !== curToNodeChild.nodeValue) {\n                                curFromNodeChild.nodeValue = curToNodeChild.nodeValue;\n                            }\n\n                        }\n                    }\n\n                    if (isCompatible) {\n                        // Advance both the \"to\" child and the \"from\" child since we found a match\n                        // Nothing else to do as we already recursively called morphChildren above\n                        curToNodeChild = toNextSibling;\n                        curFromNodeChild = fromNextSibling;\n                        continue outer;\n                    }\n\n                    // No compatible match so remove the old node from the DOM and continue trying to find a\n                    // match in the original DOM. However, we only do this if the from node is not keyed\n                    // since it is possible that a keyed node might match up with a node somewhere else in the\n                    // target tree and we don't want to discard it just yet since it still might find a\n                    // home in the final DOM tree. After everything is done we will remove any keyed nodes\n                    // that didn't find a home\n                    if (curFromNodeKey) {\n                        // Since the node is keyed it might be matched up later so we defer\n                        // the actual removal to later\n                        addKeyedRemoval(curFromNodeKey);\n                    } else {\n                        // NOTE: we skip nested keyed nodes from being removed since there is\n                        //       still a chance they will be matched up later\n                        removeNode(curFromNodeChild, fromEl, true /* skip keyed nodes */);\n                    }\n\n                    curFromNodeChild = fromNextSibling;\n                } // END: while(curFromNodeChild) {}\n\n                // If we got this far then we did not find a candidate match for\n                // our \"to node\" and we exhausted all of the children \"from\"\n                // nodes. Therefore, we will just append the current \"to\" node\n                // to the end\n                if (curToNodeKey && (matchingFromEl = fromNodesLookup[curToNodeKey]) && compareNodeNames(matchingFromEl, curToNodeChild)) {\n                    fromEl.appendChild(matchingFromEl);\n                    // MORPH\n                    morphEl(matchingFromEl, curToNodeChild);\n                } else {\n                    var onBeforeNodeAddedResult = onBeforeNodeAdded(curToNodeChild);\n                    if (onBeforeNodeAddedResult !== false) {\n                        if (onBeforeNodeAddedResult) {\n                            curToNodeChild = onBeforeNodeAddedResult;\n                        }\n\n                        if (curToNodeChild.actualize) {\n                            curToNodeChild = curToNodeChild.actualize(fromEl.ownerDocument || doc);\n                        }\n                        fromEl.appendChild(curToNodeChild);\n                        handleNodeAdded(curToNodeChild);\n                    }\n                }\n\n                curToNodeChild = toNextSibling;\n                curFromNodeChild = fromNextSibling;\n            }\n\n            cleanupFromEl(fromEl, curFromNodeChild, curFromNodeKey);\n\n            var specialElHandler = specialElHandlers[fromEl.nodeName];\n            if (specialElHandler) {\n                specialElHandler(fromEl, toEl);\n            }\n        } // END: morphChildren(...)\n\n        var morphedNode = fromNode;\n        var morphedNodeType = morphedNode.nodeType;\n        var toNodeType = toNode.nodeType;\n\n        if (!childrenOnly) {\n            // Handle the case where we are given two DOM nodes that are not\n            // compatible (e.g. <div> --> <span> or <div> --> TEXT)\n            if (morphedNodeType === ELEMENT_NODE) {\n                if (toNodeType === ELEMENT_NODE) {\n                    if (!compareNodeNames(fromNode, toNode)) {\n                        onNodeDiscarded(fromNode);\n                        morphedNode = moveChildren(fromNode, createElementNS(toNode.nodeName, toNode.namespaceURI));\n                    }\n                } else {\n                    // Going from an element node to a text node\n                    morphedNode = toNode;\n                }\n            } else if (morphedNodeType === TEXT_NODE || morphedNodeType === COMMENT_NODE) { // Text or comment node\n                if (toNodeType === morphedNodeType) {\n                    if (morphedNode.nodeValue !== toNode.nodeValue) {\n                        morphedNode.nodeValue = toNode.nodeValue;\n                    }\n\n                    return morphedNode;\n                } else {\n                    // Text node to something else\n                    morphedNode = toNode;\n                }\n            }\n        }\n\n        if (morphedNode === toNode) {\n            // The \"to node\" was not compatible with the \"from node\" so we had to\n            // toss out the \"from node\" and use the \"to node\"\n            onNodeDiscarded(fromNode);\n        } else {\n            morphEl(morphedNode, toNode, childrenOnly);\n\n            // We now need to loop over any keyed nodes that might need to be\n            // removed. We only do the removal if we know that the keyed node\n            // never found a match. When a keyed node is matched up we remove\n            // it out of fromNodesLookup and we use fromNodesLookup to determine\n            // if a keyed node has been matched up or not\n            if (keyedRemovalList) {\n                for (var i=0, len=keyedRemovalList.length; i<len; i++) {\n                    var elToRemove = fromNodesLookup[keyedRemovalList[i]];\n                    if (elToRemove) {\n                        removeNode(elToRemove, elToRemove.parentNode, false);\n                    }\n                }\n            }\n        }\n\n        if (!childrenOnly && morphedNode !== fromNode && fromNode.parentNode) {\n            if (morphedNode.actualize) {\n                morphedNode = morphedNode.actualize(fromNode.ownerDocument || doc);\n            }\n            // If we had to swap out the from node with a new node because the old\n            // node was not compatible with the target node then we need to\n            // replace the old DOM node in the original DOM tree. This is only\n            // possible if the original DOM node was part of a DOM tree which\n            // we know is the case if it has a parent node.\n            fromNode.parentNode.replaceChild(morphedNode, fromNode);\n        }\n\n        return morphedNode;\n    };\n}\n\nvar morphdom = morphdomFactory(morphAttrs);\n\n/* harmony default export */ __webpack_exports__[\"default\"] = (morphdom);\n\n\n//# sourceURL=webpack://phoenix_live_view/./node_modules/morphdom/dist/morphdom-esm.js?");

/***/ }),

/***/ "./node_modules/webpack/buildin/global.js":
/*!***********************************!*\
  !*** (webpack)/buildin/global.js ***!
  \***********************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("var g;\r\n\r\n// This works in non-strict mode\r\ng = (function() {\r\n\treturn this;\r\n})();\r\n\r\ntry {\r\n\t// This works if eval is allowed (see CSP)\r\n\tg = g || Function(\"return this\")() || (1, eval)(\"this\");\r\n} catch (e) {\r\n\t// This works if the window reference is available\r\n\tif (typeof window === \"object\") g = window;\r\n}\r\n\r\n// g can still be undefined, but nothing to do about it...\r\n// We return undefined, instead of nothing here, so it's\r\n// easier to handle this case. if(!global) { ...}\r\n\r\nmodule.exports = g;\r\n\n\n//# sourceURL=webpack://phoenix_live_view/(webpack)/buildin/global.js?");

/***/ })

/******/ });
});