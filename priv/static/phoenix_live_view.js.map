{"version":3,"file":"phoenix_live_view.js","sources":["../../assets/node_modules/morphdom/dist/morphdom-esm.js","../../assets/js/phoenix_live_view.js"],"sourcesContent":["function morphAttrs(fromNode, toNode) {\n    var attrs = toNode.attributes;\n    var i;\n    var attr;\n    var attrName;\n    var attrNamespaceURI;\n    var attrValue;\n    var fromValue;\n\n    for (i = attrs.length - 1; i >= 0; --i) {\n        attr = attrs[i];\n        attrName = attr.name;\n        attrNamespaceURI = attr.namespaceURI;\n        attrValue = attr.value;\n\n        if (attrNamespaceURI) {\n            attrName = attr.localName || attrName;\n            fromValue = fromNode.getAttributeNS(attrNamespaceURI, attrName);\n\n            if (fromValue !== attrValue) {\n                fromNode.setAttributeNS(attrNamespaceURI, attrName, attrValue);\n            }\n        } else {\n            fromValue = fromNode.getAttribute(attrName);\n\n            if (fromValue !== attrValue) {\n                fromNode.setAttribute(attrName, attrValue);\n            }\n        }\n    }\n\n    // Remove any extra attributes found on the original DOM element that\n    // weren't found on the target element.\n    attrs = fromNode.attributes;\n\n    for (i = attrs.length - 1; i >= 0; --i) {\n        attr = attrs[i];\n        if (attr.specified !== false) {\n            attrName = attr.name;\n            attrNamespaceURI = attr.namespaceURI;\n\n            if (attrNamespaceURI) {\n                attrName = attr.localName || attrName;\n\n                if (!toNode.hasAttributeNS(attrNamespaceURI, attrName)) {\n                    fromNode.removeAttributeNS(attrNamespaceURI, attrName);\n                }\n            } else {\n                if (!toNode.hasAttribute(attrName)) {\n                    fromNode.removeAttribute(attrName);\n                }\n            }\n        }\n    }\n}\n\nvar range; // Create a range object for efficently rendering strings to elements.\nvar NS_XHTML = 'http://www.w3.org/1999/xhtml';\n\nvar doc = typeof document === 'undefined' ? undefined : document;\n\nfunction toElement(str) {\n    if (!range && doc.createRange) {\n        range = doc.createRange();\n        range.selectNode(doc.body);\n    }\n\n    var fragment;\n    if (range && range.createContextualFragment) {\n        fragment = range.createContextualFragment(str);\n    } else {\n        fragment = doc.createElement('body');\n        fragment.innerHTML = str;\n    }\n    return fragment.childNodes[0];\n}\n\n/**\n * Returns true if two node's names are the same.\n *\n * NOTE: We don't bother checking `namespaceURI` because you will never find two HTML elements with the same\n *       nodeName and different namespace URIs.\n *\n * @param {Element} a\n * @param {Element} b The target element\n * @return {boolean}\n */\nfunction compareNodeNames(fromEl, toEl) {\n    var fromNodeName = fromEl.nodeName;\n    var toNodeName = toEl.nodeName;\n\n    if (fromNodeName === toNodeName) {\n        return true;\n    }\n\n    if (toEl.actualize &&\n        fromNodeName.charCodeAt(0) < 91 && /* from tag name is upper case */\n        toNodeName.charCodeAt(0) > 90 /* target tag name is lower case */) {\n        // If the target element is a virtual DOM node then we may need to normalize the tag name\n        // before comparing. Normal HTML elements that are in the \"http://www.w3.org/1999/xhtml\"\n        // are converted to upper case\n        return fromNodeName === toNodeName.toUpperCase();\n    } else {\n        return false;\n    }\n}\n\n/**\n * Create an element, optionally with a known namespace URI.\n *\n * @param {string} name the element name, e.g. 'div' or 'svg'\n * @param {string} [namespaceURI] the element's namespace URI, i.e. the value of\n * its `xmlns` attribute or its inferred namespace.\n *\n * @return {Element}\n */\nfunction createElementNS(name, namespaceURI) {\n    return !namespaceURI || namespaceURI === NS_XHTML ?\n        doc.createElement(name) :\n        doc.createElementNS(namespaceURI, name);\n}\n\n/**\n * Copies the children of one DOM element to another DOM element\n */\nfunction moveChildren(fromEl, toEl) {\n    var curChild = fromEl.firstChild;\n    while (curChild) {\n        var nextChild = curChild.nextSibling;\n        toEl.appendChild(curChild);\n        curChild = nextChild;\n    }\n    return toEl;\n}\n\nfunction syncBooleanAttrProp(fromEl, toEl, name) {\n    if (fromEl[name] !== toEl[name]) {\n        fromEl[name] = toEl[name];\n        if (fromEl[name]) {\n            fromEl.setAttribute(name, '');\n        } else {\n            fromEl.removeAttribute(name);\n        }\n    }\n}\n\nvar specialElHandlers = {\n    /**\n     * Needed for IE. Apparently IE doesn't think that \"selected\" is an\n     * attribute when reading over the attributes using selectEl.attributes\n     */\n    OPTION: function(fromEl, toEl) {\n        syncBooleanAttrProp(fromEl, toEl, 'selected');\n    },\n    /**\n     * The \"value\" attribute is special for the <input> element since it sets\n     * the initial value. Changing the \"value\" attribute without changing the\n     * \"value\" property will have no effect since it is only used to the set the\n     * initial value.  Similar for the \"checked\" attribute, and \"disabled\".\n     */\n    INPUT: function(fromEl, toEl) {\n        syncBooleanAttrProp(fromEl, toEl, 'checked');\n        syncBooleanAttrProp(fromEl, toEl, 'disabled');\n\n        if (fromEl.value !== toEl.value) {\n            fromEl.value = toEl.value;\n        }\n\n        if (!toEl.hasAttribute('value')) {\n            fromEl.removeAttribute('value');\n        }\n    },\n\n    TEXTAREA: function(fromEl, toEl) {\n        var newValue = toEl.value;\n        if (fromEl.value !== newValue) {\n            fromEl.value = newValue;\n        }\n\n        var firstChild = fromEl.firstChild;\n        if (firstChild) {\n            // Needed for IE. Apparently IE sets the placeholder as the\n            // node value and vise versa. This ignores an empty update.\n            var oldValue = firstChild.nodeValue;\n\n            if (oldValue == newValue || (!newValue && oldValue == fromEl.placeholder)) {\n                return;\n            }\n\n            firstChild.nodeValue = newValue;\n        }\n    },\n    SELECT: function(fromEl, toEl) {\n        if (!toEl.hasAttribute('multiple')) {\n            var i = 0;\n            var curChild = toEl.firstChild;\n            while(curChild) {\n                var nodeName = curChild.nodeName;\n                if (nodeName && nodeName.toUpperCase() === 'OPTION') {\n                    if (curChild.hasAttribute('selected')) {\n                        break;\n                    }\n                    i++;\n                }\n                curChild = curChild.nextSibling;\n            }\n\n            fromEl.selectedIndex = i;\n        }\n    }\n};\n\nvar ELEMENT_NODE = 1;\nvar TEXT_NODE = 3;\nvar COMMENT_NODE = 8;\n\nfunction noop() {}\n\nfunction defaultGetNodeKey(node) {\n    return node.id;\n}\n\nfunction morphdomFactory(morphAttrs) {\n\n    return function morphdom(fromNode, toNode, options) {\n        if (!options) {\n            options = {};\n        }\n\n        if (typeof toNode === 'string') {\n            if (fromNode.nodeName === '#document' || fromNode.nodeName === 'HTML') {\n                var toNodeHtml = toNode;\n                toNode = doc.createElement('html');\n                toNode.innerHTML = toNodeHtml;\n            } else {\n                toNode = toElement(toNode);\n            }\n        }\n\n        var getNodeKey = options.getNodeKey || defaultGetNodeKey;\n        var onBeforeNodeAdded = options.onBeforeNodeAdded || noop;\n        var onNodeAdded = options.onNodeAdded || noop;\n        var onBeforeElUpdated = options.onBeforeElUpdated || noop;\n        var onElUpdated = options.onElUpdated || noop;\n        var onBeforeNodeDiscarded = options.onBeforeNodeDiscarded || noop;\n        var onNodeDiscarded = options.onNodeDiscarded || noop;\n        var onBeforeElChildrenUpdated = options.onBeforeElChildrenUpdated || noop;\n        var childrenOnly = options.childrenOnly === true;\n\n        // This object is used as a lookup to quickly find all keyed elements in the original DOM tree.\n        var fromNodesLookup = {};\n        var keyedRemovalList;\n\n        function addKeyedRemoval(key) {\n            if (keyedRemovalList) {\n                keyedRemovalList.push(key);\n            } else {\n                keyedRemovalList = [key];\n            }\n        }\n\n        function walkDiscardedChildNodes(node, skipKeyedNodes) {\n            if (node.nodeType === ELEMENT_NODE) {\n                var curChild = node.firstChild;\n                while (curChild) {\n\n                    var key = undefined;\n\n                    if (skipKeyedNodes && (key = getNodeKey(curChild))) {\n                        // If we are skipping keyed nodes then we add the key\n                        // to a list so that it can be handled at the very end.\n                        addKeyedRemoval(key);\n                    } else {\n                        // Only report the node as discarded if it is not keyed. We do this because\n                        // at the end we loop through all keyed elements that were unmatched\n                        // and then discard them in one final pass.\n                        onNodeDiscarded(curChild);\n                        if (curChild.firstChild) {\n                            walkDiscardedChildNodes(curChild, skipKeyedNodes);\n                        }\n                    }\n\n                    curChild = curChild.nextSibling;\n                }\n            }\n        }\n\n        /**\n         * Removes a DOM node out of the original DOM\n         *\n         * @param  {Node} node The node to remove\n         * @param  {Node} parentNode The nodes parent\n         * @param  {Boolean} skipKeyedNodes If true then elements with keys will be skipped and not discarded.\n         * @return {undefined}\n         */\n        function removeNode(node, parentNode, skipKeyedNodes) {\n            if (onBeforeNodeDiscarded(node) === false) {\n                return;\n            }\n\n            if (parentNode) {\n                parentNode.removeChild(node);\n            }\n\n            onNodeDiscarded(node);\n            walkDiscardedChildNodes(node, skipKeyedNodes);\n        }\n\n        // // TreeWalker implementation is no faster, but keeping this around in case this changes in the future\n        // function indexTree(root) {\n        //     var treeWalker = document.createTreeWalker(\n        //         root,\n        //         NodeFilter.SHOW_ELEMENT);\n        //\n        //     var el;\n        //     while((el = treeWalker.nextNode())) {\n        //         var key = getNodeKey(el);\n        //         if (key) {\n        //             fromNodesLookup[key] = el;\n        //         }\n        //     }\n        // }\n\n        // // NodeIterator implementation is no faster, but keeping this around in case this changes in the future\n        //\n        // function indexTree(node) {\n        //     var nodeIterator = document.createNodeIterator(node, NodeFilter.SHOW_ELEMENT);\n        //     var el;\n        //     while((el = nodeIterator.nextNode())) {\n        //         var key = getNodeKey(el);\n        //         if (key) {\n        //             fromNodesLookup[key] = el;\n        //         }\n        //     }\n        // }\n\n        function indexTree(node) {\n            if (node.nodeType === ELEMENT_NODE) {\n                var curChild = node.firstChild;\n                while (curChild) {\n                    var key = getNodeKey(curChild);\n                    if (key) {\n                        fromNodesLookup[key] = curChild;\n                    }\n\n                    // Walk recursively\n                    indexTree(curChild);\n\n                    curChild = curChild.nextSibling;\n                }\n            }\n        }\n\n        indexTree(fromNode);\n\n        function handleNodeAdded(el) {\n            onNodeAdded(el);\n\n            var curChild = el.firstChild;\n            while (curChild) {\n                var nextSibling = curChild.nextSibling;\n\n                var key = getNodeKey(curChild);\n                if (key) {\n                    var unmatchedFromEl = fromNodesLookup[key];\n                    if (unmatchedFromEl && compareNodeNames(curChild, unmatchedFromEl)) {\n                        curChild.parentNode.replaceChild(unmatchedFromEl, curChild);\n                        morphEl(unmatchedFromEl, curChild);\n                    }\n                }\n\n                handleNodeAdded(curChild);\n                curChild = nextSibling;\n            }\n        }\n\n        function morphEl(fromEl, toEl, childrenOnly) {\n            var toElKey = getNodeKey(toEl);\n            var curFromNodeKey;\n\n            if (toElKey) {\n                // If an element with an ID is being morphed then it is will be in the final\n                // DOM so clear it out of the saved elements collection\n                delete fromNodesLookup[toElKey];\n            }\n\n            if (toNode.isSameNode && toNode.isSameNode(fromNode)) {\n                return;\n            }\n\n            if (!childrenOnly) {\n                if (onBeforeElUpdated(fromEl, toEl) === false) {\n                    return;\n                }\n\n                morphAttrs(fromEl, toEl);\n                onElUpdated(fromEl);\n\n                if (onBeforeElChildrenUpdated(fromEl, toEl) === false) {\n                    return;\n                }\n            }\n\n            if (fromEl.nodeName !== 'TEXTAREA') {\n                var curToNodeChild = toEl.firstChild;\n                var curFromNodeChild = fromEl.firstChild;\n                var curToNodeKey;\n\n                var fromNextSibling;\n                var toNextSibling;\n                var matchingFromEl;\n\n                outer: while (curToNodeChild) {\n                    toNextSibling = curToNodeChild.nextSibling;\n                    curToNodeKey = getNodeKey(curToNodeChild);\n\n                    while (curFromNodeChild) {\n                        fromNextSibling = curFromNodeChild.nextSibling;\n\n                        if (curToNodeChild.isSameNode && curToNodeChild.isSameNode(curFromNodeChild)) {\n                            curToNodeChild = toNextSibling;\n                            curFromNodeChild = fromNextSibling;\n                            continue outer;\n                        }\n\n                        curFromNodeKey = getNodeKey(curFromNodeChild);\n\n                        var curFromNodeType = curFromNodeChild.nodeType;\n\n                        var isCompatible = undefined;\n\n                        if (curFromNodeType === curToNodeChild.nodeType) {\n                            if (curFromNodeType === ELEMENT_NODE) {\n                                // Both nodes being compared are Element nodes\n\n                                if (curToNodeKey) {\n                                    // The target node has a key so we want to match it up with the correct element\n                                    // in the original DOM tree\n                                    if (curToNodeKey !== curFromNodeKey) {\n                                        // The current element in the original DOM tree does not have a matching key so\n                                        // let's check our lookup to see if there is a matching element in the original\n                                        // DOM tree\n                                        if ((matchingFromEl = fromNodesLookup[curToNodeKey])) {\n                                            if (curFromNodeChild.nextSibling === matchingFromEl) {\n                                                // Special case for single element removals. To avoid removing the original\n                                                // DOM node out of the tree (since that can break CSS transitions, etc.),\n                                                // we will instead discard the current node and wait until the next\n                                                // iteration to properly match up the keyed target element with its matching\n                                                // element in the original tree\n                                                isCompatible = false;\n                                            } else {\n                                                // We found a matching keyed element somewhere in the original DOM tree.\n                                                // Let's moving the original DOM node into the current position and morph\n                                                // it.\n\n                                                // NOTE: We use insertBefore instead of replaceChild because we want to go through\n                                                // the `removeNode()` function for the node that is being discarded so that\n                                                // all lifecycle hooks are correctly invoked\n                                                fromEl.insertBefore(matchingFromEl, curFromNodeChild);\n\n                                                fromNextSibling = curFromNodeChild.nextSibling;\n\n                                                if (curFromNodeKey) {\n                                                    // Since the node is keyed it might be matched up later so we defer\n                                                    // the actual removal to later\n                                                    addKeyedRemoval(curFromNodeKey);\n                                                } else {\n                                                    // NOTE: we skip nested keyed nodes from being removed since there is\n                                                    //       still a chance they will be matched up later\n                                                    removeNode(curFromNodeChild, fromEl, true /* skip keyed nodes */);\n                                                }\n\n                                                curFromNodeChild = matchingFromEl;\n                                            }\n                                        } else {\n                                            // The nodes are not compatible since the \"to\" node has a key and there\n                                            // is no matching keyed node in the source tree\n                                            isCompatible = false;\n                                        }\n                                    }\n                                } else if (curFromNodeKey) {\n                                    // The original has a key\n                                    isCompatible = false;\n                                }\n\n                                isCompatible = isCompatible !== false && compareNodeNames(curFromNodeChild, curToNodeChild);\n                                if (isCompatible) {\n                                    // We found compatible DOM elements so transform\n                                    // the current \"from\" node to match the current\n                                    // target DOM node.\n                                    morphEl(curFromNodeChild, curToNodeChild);\n                                }\n\n                            } else if (curFromNodeType === TEXT_NODE || curFromNodeType == COMMENT_NODE) {\n                                // Both nodes being compared are Text or Comment nodes\n                                isCompatible = true;\n                                // Simply update nodeValue on the original node to\n                                // change the text value\n                                if (curFromNodeChild.nodeValue !== curToNodeChild.nodeValue) {\n                                    curFromNodeChild.nodeValue = curToNodeChild.nodeValue;\n                                }\n\n                            }\n                        }\n\n                        if (isCompatible) {\n                            // Advance both the \"to\" child and the \"from\" child since we found a match\n                            curToNodeChild = toNextSibling;\n                            curFromNodeChild = fromNextSibling;\n                            continue outer;\n                        }\n\n                        // No compatible match so remove the old node from the DOM and continue trying to find a\n                        // match in the original DOM. However, we only do this if the from node is not keyed\n                        // since it is possible that a keyed node might match up with a node somewhere else in the\n                        // target tree and we don't want to discard it just yet since it still might find a\n                        // home in the final DOM tree. After everything is done we will remove any keyed nodes\n                        // that didn't find a home\n                        if (curFromNodeKey) {\n                            // Since the node is keyed it might be matched up later so we defer\n                            // the actual removal to later\n                            addKeyedRemoval(curFromNodeKey);\n                        } else {\n                            // NOTE: we skip nested keyed nodes from being removed since there is\n                            //       still a chance they will be matched up later\n                            removeNode(curFromNodeChild, fromEl, true /* skip keyed nodes */);\n                        }\n\n                        curFromNodeChild = fromNextSibling;\n                    }\n\n                    // If we got this far then we did not find a candidate match for\n                    // our \"to node\" and we exhausted all of the children \"from\"\n                    // nodes. Therefore, we will just append the current \"to\" node\n                    // to the end\n                    if (curToNodeKey && (matchingFromEl = fromNodesLookup[curToNodeKey]) && compareNodeNames(matchingFromEl, curToNodeChild)) {\n                        fromEl.appendChild(matchingFromEl);\n                        morphEl(matchingFromEl, curToNodeChild);\n                    } else {\n                        var onBeforeNodeAddedResult = onBeforeNodeAdded(curToNodeChild);\n                        if (onBeforeNodeAddedResult !== false) {\n                            if (onBeforeNodeAddedResult) {\n                                curToNodeChild = onBeforeNodeAddedResult;\n                            }\n\n                            if (curToNodeChild.actualize) {\n                                curToNodeChild = curToNodeChild.actualize(fromEl.ownerDocument || doc);\n                            }\n                            fromEl.appendChild(curToNodeChild);\n                            handleNodeAdded(curToNodeChild);\n                        }\n                    }\n\n                    curToNodeChild = toNextSibling;\n                    curFromNodeChild = fromNextSibling;\n                }\n\n                // We have processed all of the \"to nodes\". If curFromNodeChild is\n                // non-null then we still have some from nodes left over that need\n                // to be removed\n                while (curFromNodeChild) {\n                    fromNextSibling = curFromNodeChild.nextSibling;\n                    if ((curFromNodeKey = getNodeKey(curFromNodeChild))) {\n                        // Since the node is keyed it might be matched up later so we defer\n                        // the actual removal to later\n                        addKeyedRemoval(curFromNodeKey);\n                    } else {\n                        // NOTE: we skip nested keyed nodes from being removed since there is\n                        //       still a chance they will be matched up later\n                        removeNode(curFromNodeChild, fromEl, true /* skip keyed nodes */);\n                    }\n                    curFromNodeChild = fromNextSibling;\n                }\n            }\n\n            var specialElHandler = specialElHandlers[fromEl.nodeName];\n            if (specialElHandler) {\n                specialElHandler(fromEl, toEl);\n            }\n        } // END: morphEl(...)\n\n        var morphedNode = fromNode;\n        var morphedNodeType = morphedNode.nodeType;\n        var toNodeType = toNode.nodeType;\n\n        if (!childrenOnly) {\n            // Handle the case where we are given two DOM nodes that are not\n            // compatible (e.g. <div> --> <span> or <div> --> TEXT)\n            if (morphedNodeType === ELEMENT_NODE) {\n                if (toNodeType === ELEMENT_NODE) {\n                    if (!compareNodeNames(fromNode, toNode)) {\n                        onNodeDiscarded(fromNode);\n                        morphedNode = moveChildren(fromNode, createElementNS(toNode.nodeName, toNode.namespaceURI));\n                    }\n                } else {\n                    // Going from an element node to a text node\n                    morphedNode = toNode;\n                }\n            } else if (morphedNodeType === TEXT_NODE || morphedNodeType === COMMENT_NODE) { // Text or comment node\n                if (toNodeType === morphedNodeType) {\n                    if (morphedNode.nodeValue !== toNode.nodeValue) {\n                        morphedNode.nodeValue = toNode.nodeValue;\n                    }\n\n                    return morphedNode;\n                } else {\n                    // Text node to something else\n                    morphedNode = toNode;\n                }\n            }\n        }\n\n        if (morphedNode === toNode) {\n            // The \"to node\" was not compatible with the \"from node\" so we had to\n            // toss out the \"from node\" and use the \"to node\"\n            onNodeDiscarded(fromNode);\n        } else {\n            morphEl(morphedNode, toNode, childrenOnly);\n\n            // We now need to loop over any keyed nodes that might need to be\n            // removed. We only do the removal if we know that the keyed node\n            // never found a match. When a keyed node is matched up we remove\n            // it out of fromNodesLookup and we use fromNodesLookup to determine\n            // if a keyed node has been matched up or not\n            if (keyedRemovalList) {\n                for (var i=0, len=keyedRemovalList.length; i<len; i++) {\n                    var elToRemove = fromNodesLookup[keyedRemovalList[i]];\n                    if (elToRemove) {\n                        removeNode(elToRemove, elToRemove.parentNode, false);\n                    }\n                }\n            }\n        }\n\n        if (!childrenOnly && morphedNode !== fromNode && fromNode.parentNode) {\n            if (morphedNode.actualize) {\n                morphedNode = morphedNode.actualize(fromNode.ownerDocument || doc);\n            }\n            // If we had to swap out the from node with a new node because the old\n            // node was not compatible with the target node then we need to\n            // replace the old DOM node in the original DOM tree. This is only\n            // possible if the original DOM node was part of a DOM tree which\n            // we know is the case if it has a parent node.\n            fromNode.parentNode.replaceChild(morphedNode, fromNode);\n        }\n\n        return morphedNode;\n    };\n}\n\nvar morphdom = morphdomFactory(morphAttrs);\n\nexport default morphdom;\n","/*\n================================================================================\nPhoenix LiveView JavaScript Client\n================================================================================\n\n## Usage\n\nInstantiate a single LiveSocket instance to enable LiveView\nclient/server interaction, for example:\n\n    import LiveSocket from \"live_view\"\n\n    let liveSocket = new LiveSocket(\"/live\")\n    liveSocket.connect()\n\nA LiveSocket can also be created from an existing socket:\n\n    import { Socket } from \"phoenix\"\n    import LiveSocket from \"live_view\"\n\n    let socket = new Socket(\"/live\")\n    let liveSocket = new LiveSocket(socket)\n    liveSocket.connect()\n\nAll options are passed directly to the `Phoenix.Socket` constructor,\nexcept for the following LiveView specific options:\n\n  * `bindingPrefix` - the prefix to use for phoenix bindings. Defaults `\"phx-\"`\n\n## Events\n\n### Click Events\n\nWhen pushed, the value sent to the server will be chosen with the\nfollowing priority:\n\n  - An optional `\"phx-value\"` binding on the clicked element\n  - The clicked element's `value` property\n  - An empty string\n\n### Key Events\n\nThe onkeydown and onkeyup events are supported via\nthe `phx-keydown`, and `phx-keyup` bindings. By\ndefault, the bound element will be the event listener, but an\noptional `phx-target` may be provided which may be `\"window\"`.\n\nWhen pushed, the value sent to the server will be the event's `key`.\n\n### Focus and Blur Events\n\nFocus and blur events may be bound to DOM elements that emit\nsuch events, using the `phx-blur`, and `phx-focus` bindings, for example:\n\n    <input name=\"email\" phx-focus=\"myfocus\" phx-blur=\"myblur\"/>\n\nTo detect when the page itself has receive focus or blur,\n`phx-target` may be specified as `\"window\"`. Like other\nbindings, a `phx-value` can be provided on the bound element,\notherwise the input's value will be used. For example:\n\n    <div class=\"container\"\n        phx-focus=\"page-active\"\n        phx-blur=\"page-inactive\"\n        phx-target=\"window\">\n    ...\n    </div>\n\n## Forms and input handling\n\nThe JavaScript client is always the source of truth for current\ninput values. For any given input with focus, LiveView will never\noverwrite the input's current value, even if it deviates from\nthe server's rendered updates. This works well for updates where\nmajor side effects are not expected, such as form validation errors,\nor additive UX around the user's input values as they fill out a form.\nFor these use cases, the `phx-change` input does not concern itself\nwith disabling input editing while an event to the server is inflight.\n\nThe `phx-submit` event is used for form submissions where major side-effects\ntypically happen, such as rendering new containers, calling an external\nservice, or redirecting to a new page. For these use-cases, the form inputs\nare set to `readonly` on submit, and any submit button is disabled until\nthe client gets an acknowledgment that the server has processed the\n`phx-submit` event. Following an acknowledgment, any updates are patched\nto the DOM as normal, and the last input with focus is restored if the\nuser has not otherwise focused on a new input during submission.\n\nTo handle latent form submissions, any HTML tag can be annotated with\n`phx-disable-with`, which swaps the element's `innerText` with the provided\nvalue during form submission. For example, the following code would change\nthe \"Save\" button to \"Saving...\", and restore it to \"Save\" on acknowledgment:\n\n    <button type=\"submit\" phx-disable-with=\"Saving...\">Save</button>\n\n\n## Loading state and Errors\n\nBy default, the following classes are applied to the live view's parent\ncontainer:\n\n  - `\"phx-connected\"` - applied when the view has connected to the server\n  - `\"phx-disconnected\"` - applied when the view is not connected to the server\n  - `\"phx-error\"` - applied when an error occurs on the server. Note, this\n    class will be applied in conjunction with `\"phx-disconnected\"` connection\n    to the server is lost.\n\nWhen a form bound with `phx-submit` is submitted, the `phx-loading` class\nis applied to the form, which is removed on update.\n\nIn addition to applied classes, an empty `\"phx-loader\"` exists adjacent\nto every LiveView, and its display status is toggled automatically based on\nconnection and error class changes. This behavior may be disabled by overriding\n`.phx-loader` in your css to `display: none !important`.\n*/\n\nimport morphdom from \"morphdom\"\n\nconst PHX_VIEW = \"data-phx-view\"\nconst PHX_CONNECTED_CLASS = \"phx-connected\"\nconst PHX_LOADING_CLASS = \"phx-loading\"\nconst PHX_DISCONNECTED_CLASS = \"phx-disconnected\"\nconst PHX_ERROR_CLASS = \"phx-error\"\nconst PHX_PARENT_ID = \"data-phx-parent-id\"\nconst PHX_VIEW_SELECTOR = `[${PHX_VIEW}]`\nconst PHX_ERROR_FOR = \"data-phx-error-for\"\nconst PHX_HAS_FOCUSED = \"data-phx-has-focused\"\nconst PHX_BOUND = \"data-phx-bound\"\nconst FOCUSABLE_INPUTS = [\"text\", \"textarea\", \"number\", \"email\", \"password\", \"search\", \"tel\", \"url\"]\nconst PHX_HAS_SUBMITTED = \"data-phx-has-submitted\"\nconst PHX_SESSION = \"data-phx-session\"\nconst PHX_READONLY = \"data-phx-readonly\"\nconst PHX_DISABLED = \"data-phx-disabled\"\nconst PHX_DISABLE_WITH = \"disable-with\"\nconst LOADER_TIMEOUT = 100\nconst LOADER_ZOOM = 2\nconst BINDING_PREFIX = \"phx-\"\nconst PUSH_TIMEOUT = 20000\n\nexport let debug = (view, kind, msg, obj) => {\n  console.log(`${view.id} ${kind}: ${msg} - `, obj)\n}\n\nlet closestPhxBinding = (el, binding) => {\n  do {\n    if(el.matches(`[${binding}]`)){ return el }\n    el = el.parentElement || el.parentNode\n  } while(el !== null && el.nodeType === 1 && !el.matches(PHX_VIEW_SELECTOR))\n  return null\n}\n\nlet isObject = (obj) => {\n  return typeof(obj) === \"object\" && !(obj instanceof Array)\n}\n\nlet isEmpty = (obj) => {\n  return Object.keys(obj).length === 0\n}\n\nlet maybe = (el, key) => {\n  if(el){\n    return el[key]\n  } else {\n    return null\n  }\n}\n\nlet serializeForm = (form) => {\n  return((new URLSearchParams(new FormData(form))).toString())\n}\n\nlet recursiveMerge = (target, source) => {\n  for(let key in source){\n    let val = source[key]\n    if(isObject(val) && target[key]){\n      recursiveMerge(target[key], val)\n    } else {\n      target[key] = val\n    }\n  }\n}\n\nexport let Rendered = {\n  mergeDiff(source, diff){\n    if(this.isNewFingerprint(diff)){\n      return diff\n    } else {\n      recursiveMerge(source, diff)\n      return source\n    }\n  },\n\n  isNewFingerprint(diff = {}){ return !!diff.static },\n\n  toString(rendered){\n    let output = {buffer: \"\"}\n    this.toOutputBuffer(rendered, output)\n    return output.buffer\n  },\n\n  toOutputBuffer(rendered, output){\n    if(rendered.dynamics){ return this.comprehensionToBuffer(rendered, output) }\n    let {static: statics} = rendered\n\n    output.buffer += statics[0]\n    for(let i = 1; i < statics.length; i++){\n      this.dynamicToBuffer(rendered[i - 1], output)\n      output.buffer += statics[i]\n    }\n  },\n\n  comprehensionToBuffer(rendered, output){\n    let {dynamics: dynamics, static: statics} = rendered\n\n    for(let d = 0; d < dynamics.length; d++){\n      let dynamic = dynamics[d]\n      output.buffer += statics[0]\n      for(let i = 1; i < statics.length; i++){\n        this.dynamicToBuffer(dynamic[i - 1], output)\n        output.buffer += statics[i]\n      }\n    }\n  },\n\n  dynamicToBuffer(rendered, output){\n    if(isObject(rendered)){\n      this.toOutputBuffer(rendered, output)\n    } else {\n      output.buffer += rendered\n    }\n  }\n}\n\n// todo document LiveSocket specific options like viewLogger\nexport class LiveSocket {\n  constructor(url, opts = {}){\n    this.unloaded = false\n    const Socket = window.PhxSocket\n    this.socket = new Socket(url, opts)\n    this.socket.onOpen(() => {\n      if(this.isUnloaded()){\n        this.destroyAllViews()\n        this.joinRootViews()\n      }\n\n      this.unloaded = false\n    })\n    window.addEventListener(\"beforeunload\", e => {\n      this.unloaded = true\n    })\n    this.bindingPrefix = opts.bindingPrefix || BINDING_PREFIX\n    this.opts = opts\n    this.views = {}\n    this.viewLogger = opts.viewLogger\n    this.activeElement = null\n    this.prevActive = null\n    this.silenced = false\n    this.bindTopLevelEvents()\n  }\n\n  isUnloaded(){ return this.unloaded }\n\n  getSocket(){ return this.socket }\n\n  log(view, kind, msgCallback){\n    if(this.viewLogger){\n      let [msg, obj] = msgCallback()\n      this.viewLogger(view, kind, msg, obj)\n    }\n  }\n\n  connect(){\n    if([\"complete\", \"loaded\",\"interactive\"].indexOf(document.readyState) >= 0){\n      this.joinRootViews()\n    } else {\n      document.addEventListener(\"DOMContentLoaded\", () => {\n        this.joinRootViews()\n      })\n    }\n    return this.socket.connect()\n  }\n\n  getBindingPrefix(){ return this.bindingPrefix }\n\n  binding(kind){ return `${this.getBindingPrefix()}${kind}` }\n\n  disconnect(){\n    this.socket.disconnect()\n  }\n\n  channel(topic, params){ return this.socket.channel(topic, params || {}) }\n\n  joinRootViews(){\n    document.querySelectorAll(`${PHX_VIEW_SELECTOR}:not([${PHX_PARENT_ID}])`).forEach(rootEl => {\n      this.joinView(rootEl)\n    })\n  }\n\n  joinView(el, parentView){\n    if(this.getViewById(el.id)){ return }\n\n    let view = new View(el, this, parentView)\n    this.views[view.id] = view\n    view.join()\n  }\n\n  owner(childEl, callback){\n    let view = this.getViewById(maybe(childEl.closest(PHX_VIEW_SELECTOR), \"id\"))\n    if(view){ callback(view) }\n  }\n\n  getViewById(id){ return this.views[id] }\n\n  onViewError(view){\n    this.dropActiveElement(view)\n  }\n\n  destroyAllViews(){\n    for(let id in this.views){ this.destroyViewById(id) }\n  }\n\n  destroyViewById(id){\n    let view = this.views[id]\n    if(view){\n      delete this.views[view.id]\n      view.destroy()\n    }\n  }\n\n  setActiveElement(target){\n    if(this.activeElement === target){ return }\n    this.activeElement = target\n    let cancel = () => {\n      if(target === this.activeElement){ this.activeElement = null }\n      target.removeEventListener(\"mouseup\", this)\n      target.removeEventListener(\"touchend\", this)\n    }\n    target.addEventListener(\"mouseup\", cancel)\n    target.addEventListener(\"touchend\", cancel)\n  }\n\n  getActiveElement(){\n    if(document.activeElement === document.body){\n      return this.activeElement || document.activeElement\n    } else {\n      return document.activeElement\n    }\n  }\n\n  dropActiveElement(view){\n    if(this.prevActive && view.ownsElement(this.prevActive)){\n      this.prevActive = null\n    }\n  }\n\n  restorePreviouslyActiveFocus(){\n    if(this.prevActive && this.prevActive !== document.body){\n      this.prevActive.focus()\n    }\n  }\n\n  blurActiveElement(){\n    this.prevActive = this.getActiveElement()\n    if(this.prevActive !== document.body){ this.prevActive.blur() }\n  }\n\n  bindTopLevelEvents(){\n    this.bindClicks()\n    this.bindForms()\n    this.bindTargetable({keyup: \"keyup\", keydown: \"keydown\"}, (e, type, view, target, phxEvent, phxTarget) => {\n      view.pushKey(target, type, e, phxEvent)\n    })\n    this.bindTargetable({blur: \"focusout\", focus: \"focusin\"}, (e, type, view, targetEl, phxEvent, phxTarget) => {\n      if(!phxTarget){\n        view.pushEvent(type, targetEl, phxEvent)\n      }\n    })\n    this.bindTargetable({blur: \"blur\", focus: \"focus\"}, (e, type, view, targetEl, phxEvent, phxTarget) => {\n      // blur and focus are triggered on document and window. Discard one to avoid dups\n      if(phxTarget && !phxTarget !== \"window\"){\n        view.pushEvent(type, targetEl, phxEvent)\n      }\n    })\n\n  }\n\n  // private\n\n  bindTargetable(events, callback){\n    for(let event in events){\n      let browserEventName = events[event]\n\n      this.on(browserEventName, e => {\n        let binding = this.binding(event)\n        let bindTarget = this.binding(\"target\")\n        let targetPhxEvent = e.target.getAttribute && e.target.getAttribute(binding)\n        if(targetPhxEvent && !e.target.getAttribute(bindTarget)){\n          this.owner(e.target, view => callback(e, event, view, e.target, targetPhxEvent, null))\n        } else {\n          document.querySelectorAll(`[${binding}][${bindTarget}=window]`).forEach(el => {\n            let phxEvent = el.getAttribute(binding)\n            this.owner(el, view => callback(e, event, view, el, phxEvent, \"window\"))\n          })\n        }\n      })\n    }\n  }\n\n  bindClicks(){\n    window.addEventListener(\"click\", e => {\n      let click = this.binding(\"click\")\n      let target = closestPhxBinding(e.target, click)\n      let phxEvent = target && target.getAttribute(click)\n      if(!phxEvent){ return }\n      e.preventDefault()\n      this.owner(target, view => view.pushEvent(\"click\", target, phxEvent))\n    }, false)\n  }\n\n  bindForms(){\n    this.on(\"submit\", e => {\n      let phxEvent = e.target.getAttribute(this.binding(\"submit\"))\n      if(!phxEvent){ return }\n      e.preventDefault()\n      e.target.disabled = true\n      this.owner(e.target, view => view.submitForm(e.target, phxEvent))\n    }, false)\n\n    for(let type of [\"change\", \"input\"]){\n      this.on(type, e => {\n        let input = e.target\n        if(type === \"input\" && [\"checkbox\", \"radio\", \"select-one\", \"select-multiple\"].includes(input.type)){ return }\n\n        let phxEvent = input.form && input.form.getAttribute(this.binding(\"change\"))\n        if(!phxEvent){ return }\n        this.owner(input, view => {\n          if(DOM.isTextualInput(input)){\n            input.setAttribute(PHX_HAS_FOCUSED, true)\n          } else {\n            this.setActiveElement(input)\n          }\n          view.pushInput(input, phxEvent)\n        })\n      }, false)\n    }\n  }\n\n  silenceEvents(callback){\n    this.silenced = true\n    callback()\n    this.silenced = false\n  }\n\n  on(event, callback){\n    window.addEventListener(event, e => {\n      if(!this.silenced){ callback(e) }\n    })\n  }\n}\n\nexport let Browser = {\n  setCookie(name, value){\n    document.cookie = `${name}=${value}`\n  },\n\n  getCookie(name){\n    return document.cookie.replace(new RegExp(`(?:(?:^|.*;\\s*)${name}\\s*\\=\\s*([^;]*).*$)|^.*$`), \"$1\")\n  },\n\n  redirect(toURL, flash){\n    if(flash){ Browser.setCookie(\"__phoenix_flash__\", flash + \"; max-age=60000; path=/\") }\n    window.location = toURL\n  }\n}\n\nlet DOM = {\n\n  disableForm(form, prefix){\n    let disableWith = `${prefix}${PHX_DISABLE_WITH}`\n    form.classList.add(PHX_LOADING_CLASS)\n    form.querySelectorAll(`[${disableWith}]`).forEach(el => {\n      let value = el.getAttribute(disableWith)\n      el.setAttribute(`${disableWith}-restore`, el.innerText)\n      el.innerText = value\n    })\n    form.querySelectorAll(\"button\").forEach(button => {\n      button.setAttribute(PHX_DISABLED, button.disabled)\n      button.disabled = true\n    })\n    form.querySelectorAll(\"input\").forEach(input => {\n      input.setAttribute(PHX_READONLY, input.readOnly)\n      input.readOnly = true\n    })\n  },\n\n  restoreDisabledForm(form, prefix){\n    let disableWith = `${prefix}${PHX_DISABLE_WITH}`\n    form.classList.remove(PHX_LOADING_CLASS)\n    form.querySelectorAll(`[${disableWith}]`).forEach(el => {\n      let value = el.getAttribute(`${disableWith}-restore`)\n      if(value){\n        el.innerText = value\n        el.removeAttribute(`${disableWith}-restore`)\n      }\n    })\n    form.querySelectorAll(\"button\").forEach(button => {\n      let prev = button.getAttribute(PHX_DISABLED)\n      if(prev){\n        button.disabled = prev === \"true\"\n        button.removeAttribute(PHX_DISABLED)\n      }\n    })\n    form.querySelectorAll(\"input\").forEach(input => {\n      let prev = input.getAttribute(PHX_READONLY)\n      if(prev){\n        input.readOnly = prev === \"true\"\n        input.removeAttribute(PHX_READONLY)\n      }\n    })\n  },\n\n  discardError(el){\n    let field = el.getAttribute && el.getAttribute(PHX_ERROR_FOR)\n    if(!field) { return }\n    let input = document.getElementById(field)\n\n    if(field && !(input.getAttribute(PHX_HAS_FOCUSED) || input.form.getAttribute(PHX_HAS_SUBMITTED))){\n      el.style.display = \"none\"\n    }\n  },\n\n  isPhxChild(node){\n    return node.getAttribute && node.getAttribute(PHX_PARENT_ID)\n  },\n\n  patch(view, container, id, html){\n    let focused = view.liveSocket.getActiveElement()\n    let selectionStart = null\n    let selectionEnd = null\n    if(DOM.isTextualInput(focused)){\n      selectionStart = focused.selectionStart\n      selectionEnd = focused.selectionEnd\n    }\n\n    morphdom(container, `<div>${html}</div>`, {\n      childrenOnly: true,\n      onBeforeNodeAdded: function(el){\n        //input handling\n        DOM.discardError(el)\n        return el\n      },\n      onNodeAdded: function(el){\n        // nested view handling\n        if(DOM.isPhxChild(el) && view.ownsElement(el)){\n          view.onNewChildAdded(el)\n          return true\n        }\n      },\n      onBeforeNodeDiscarded: function(el){\n        // nested view handling\n        if(DOM.isPhxChild(el)){\n          view.liveSocket.destroyViewById(el.id)\n          return true\n        }\n      },\n      onBeforeElUpdated: function(fromEl, toEl) {\n        // nested view handling\n        if(DOM.isPhxChild(toEl)){\n          DOM.mergeAttrs(fromEl, toEl)\n          return false\n        }\n\n        // input handling\n        if(fromEl.getAttribute && fromEl.getAttribute(PHX_HAS_SUBMITTED)){\n          toEl.setAttribute(PHX_HAS_SUBMITTED, true)\n        }\n        if(fromEl.getAttribute && fromEl.getAttribute(PHX_HAS_FOCUSED)){\n          toEl.setAttribute(PHX_HAS_FOCUSED, true)\n        }\n        DOM.discardError(toEl)\n\n        if(DOM.isTextualInput(fromEl) && fromEl === focused){\n          DOM.mergeInputs(fromEl, toEl)\n          return false\n        } else {\n          return true\n        }\n      }\n    })\n\n    view.liveSocket.silenceEvents(() => {\n      DOM.restoreFocus(focused, selectionStart, selectionEnd)\n    })\n    document.dispatchEvent(new Event(\"phx:update\"))\n  },\n\n  mergeAttrs(target, source){\n    source.getAttributeNames().forEach(name => {\n      let value = source.getAttribute(name)\n      target.setAttribute(name, value)\n    })\n  },\n\n  mergeInputs(target, source){\n    DOM.mergeAttrs(target, source)\n    target.readOnly = source.readOnly\n  },\n\n  restoreFocus(focused, selectionStart, selectionEnd){\n    if(!DOM.isTextualInput(focused)){ return }\n    if(focused.value === \"\" || focused.readOnly){ focused.blur()}\n    focused.focus()\n    if(focused.setSelectionRange && focused.type === \"text\" || focused.type === \"textarea\"){\n      focused.setSelectionRange(selectionStart, selectionEnd)\n    }\n  },\n\n  isTextualInput(el){\n    return FOCUSABLE_INPUTS.indexOf(el.type) >= 0\n  }\n}\n\nexport class View {\n  constructor(el, liveSocket, parentView){\n    this.liveSocket = liveSocket\n    this.parent = parentView\n    this.newChildrenAdded = false\n    this.gracefullyClosed = false\n    this.el = el\n    this.loader = this.el.nextElementSibling\n    this.id = this.el.id\n    this.view = this.el.getAttribute(PHX_VIEW)\n    this.channel = this.liveSocket.channel(`lv:${this.id}`, () => {\n      return {session: this.getSession()}\n    })\n    this.loaderTimer = setTimeout(() => this.showLoader(), LOADER_TIMEOUT)\n    this.bindChannel()\n  }\n\n  getSession(){\n    return this.el.getAttribute(PHX_SESSION)\n  }\n\n  destroy(callback = function(){}){\n    if(this.hasGracefullyClosed()){\n      this.log(\"destroyed\", () => [\"the server view has gracefully closed\"])\n      callback()\n    } else {\n      this.log(\"destroyed\", () => [\"the child has been removed from the parent\"])\n      this.channel.leave()\n        .receive(\"ok\", callback)\n        .receive(\"error\", callback)\n        .receive(\"timeout\", callback)\n    }\n  }\n\n  hideLoader(){\n    clearTimeout(this.loaderTimer)\n    this.loader.style.display = \"none\"\n  }\n\n  showLoader(){\n    clearTimeout(this.loaderTimer)\n    this.el.classList = PHX_DISCONNECTED_CLASS\n    this.loader.style.display = \"block\"\n    let middle = Math.floor(this.el.clientHeight / LOADER_ZOOM)\n    this.loader.style.top = `-${middle}px`\n  }\n\n  log(kind, msgCallback){\n    this.liveSocket.log(this, kind, msgCallback)\n  }\n\n  onJoin({rendered}){\n    this.log(\"join\", () => [\"\", JSON.stringify(rendered)])\n    this.rendered = rendered\n    this.hideLoader()\n    this.el.classList = PHX_CONNECTED_CLASS\n    DOM.patch(this, this.el, this.id, Rendered.toString(this.rendered))\n    this.joinNewChildren()\n  }\n\n  joinNewChildren(){\n    let selector = `${PHX_VIEW_SELECTOR}[${PHX_PARENT_ID}=\"${this.id}\"]`\n    document.querySelectorAll(selector).forEach(childEl => {\n      let child = this.liveSocket.getViewById(childEl.id)\n      if(!child){\n        this.liveSocket.joinView(childEl, this)\n      }\n    })\n  }\n\n  update(diff){\n    if(isEmpty(diff)){ return }\n    this.log(\"update\", () => [\"\", JSON.stringify(diff)])\n    this.rendered = Rendered.mergeDiff(this.rendered, diff)\n    let html = Rendered.toString(this.rendered)\n    this.newChildrenAdded = false\n    DOM.patch(this, this.el, this.id, html)\n    if(this.newChildrenAdded){ this.joinNewChildren() }\n  }\n\n  onNewChildAdded(el){\n    this.newChildrenAdded = true\n  }\n\n  bindChannel(){\n    this.channel.on(\"render\", (diff) => this.update(diff))\n    this.channel.on(\"redirect\", ({to, flash}) => Browser.redirect(to, flash))\n    this.channel.on(\"session\", ({token}) => this.el.setAttribute(PHX_SESSION, token))\n    this.channel.onError(reason => this.onError(reason))\n    this.channel.onClose(() => this.onGracefulClose())\n  }\n\n  onGracefulClose(){\n    this.gracefullyClosed = true\n    this.liveSocket.destroyViewById(this.id)\n  }\n\n  hasGracefullyClosed(){ return this.gracefullyClosed }\n\n  join(){\n    if(this.parent){\n      this.parent.channel.onClose(() => this.onGracefulClose())\n      this.parent.channel.onError(() => this.liveSocket.destroyViewById(this.id))\n    }\n    this.channel.join()\n      .receive(\"ok\", data => this.onJoin(data))\n      .receive(\"error\", resp => this.onJoinError(resp))\n      .receive(\"timeout\", () => this.onJoinError(\"timeout\"))\n  }\n\n  onJoinError(resp){\n    this.displayError()\n    this.log(\"error\", () => [\"unable to join\", resp])\n  }\n\n  onError(reason){\n    this.log(\"error\", () => [\"view crashed\", reason])\n    this.liveSocket.onViewError(this)\n    document.activeElement.blur()\n    if(this.liveSocket.isUnloaded()){\n      this.showLoader()\n    } else {\n      this.displayError()\n    }\n  }\n\n  displayError(){\n    this.showLoader()\n    this.el.classList = `${PHX_DISCONNECTED_CLASS} ${PHX_ERROR_CLASS}`\n  }\n\n  pushWithReply(event, payload, onReply = function(){ }){\n    this.channel.push(event, payload, PUSH_TIMEOUT)\n      .receive(\"ok\", diff => {\n        this.update(diff)\n        onReply()\n      })\n  }\n\n  pushEvent(type, el, phxEvent){\n    let val = el.getAttribute(this.binding(\"value\")) || el.value || \"\"\n    this.pushWithReply(\"event\", {\n      type: type,\n      event: phxEvent,\n      value: val\n    })\n  }\n\n  pushKey(keyElement, kind, event, phxEvent){\n    this.pushWithReply(\"event\", {\n      type: kind,\n      event: phxEvent,\n      value: keyElement.value || event.key\n    })\n  }\n\n  pushInput(inputEl, phxEvent){\n    this.pushWithReply(\"event\", {\n      type: \"form\",\n      event: phxEvent,\n      value: serializeForm(inputEl.form)\n    })\n  }\n\n  pushFormSubmit(formEl, phxEvent, onReply){\n    this.pushWithReply(\"event\", {\n      type: \"form\",\n      event: phxEvent,\n      value: serializeForm(formEl)\n    }, onReply)\n  }\n\n  ownsElement(element){\n    return element.getAttribute(PHX_PARENT_ID) === this.id ||\n           maybe(element.closest(PHX_VIEW_SELECTOR), \"id\") === this.id\n  }\n\n  submitForm(form, phxEvent){\n    let prefix = this.liveSocket.getBindingPrefix()\n    form.setAttribute(PHX_HAS_SUBMITTED, \"true\")\n    DOM.disableForm(form, prefix)\n    this.liveSocket.blurActiveElement(this)\n    this.pushFormSubmit(form, phxEvent, () => {\n      DOM.restoreDisabledForm(form, prefix)\n      this.liveSocket.restorePreviouslyActiveFocus()\n    })\n  }\n\n  binding(kind){ return this.liveSocket.binding(kind)}\n}\n\nexport default LiveSocket\n"],"names":["range","NS_XHTML","doc","document","undefined","compareNodeNames","fromEl","toEl","fromNodeName","nodeName","toNodeName","actualize","charCodeAt","toUpperCase","syncBooleanAttrProp","name","setAttribute","removeAttribute","specialElHandlers","OPTION","INPUT","value","hasAttribute","TEXTAREA","newValue","firstChild","oldValue","nodeValue","placeholder","SELECT","i","curChild","nextSibling","selectedIndex","ELEMENT_NODE","TEXT_NODE","COMMENT_NODE","noop","defaultGetNodeKey","node","id","morphdom","morphAttrs","fromNode","toNode","options","toNodeHtml","createElement","innerHTML","str","createRange","selectNode","body","createContextualFragment","fragment","childNodes","keyedRemovalList","getNodeKey","onBeforeNodeAdded","onNodeAdded","onBeforeElUpdated","onElUpdated","onBeforeNodeDiscarded","onNodeDiscarded","onBeforeElChildrenUpdated","childrenOnly","fromNodesLookup","addKeyedRemoval","key","push","removeNode","parentNode","skipKeyedNodes","removeChild","walkDiscardedChildNodes","nodeType","handleNodeAdded","el","unmatchedFromEl","replaceChild","morphEl","curFromNodeKey","toElKey","isSameNode","curToNodeKey","fromNextSibling","toNextSibling","matchingFromEl","curToNodeChild","curFromNodeChild","outer","curFromNodeType","isCompatible","insertBefore","appendChild","onBeforeNodeAddedResult","ownerDocument","specialElHandler","indexTree","namespaceURI","morphedNode","morphedNodeType","toNodeType","nextChild","moveChildren","createElementNS","len","length","elToRemove","morphdomFactory","attr","attrName","attrNamespaceURI","attrValue","attrs","attributes","localName","getAttributeNS","setAttributeNS","getAttribute","specified","hasAttributeNS","removeAttributeNS","PHX_VIEW","PHX_VIEW_SELECTOR","FOCUSABLE_INPUTS","LOADER_TIMEOUT","BINDING_PREFIX","debug","view","kind","msg","obj","console","log","isObject","_typeof","Array","maybe","serializeForm","form","URLSearchParams","FormData","toString","Rendered","mergeDiff","source","diff","this","isNewFingerprint","recursiveMerge","target","val","rendered","output","buffer","toOutputBuffer","dynamics","comprehensionToBuffer","statics","dynamicToBuffer","d","dynamic","LiveSocket","url","opts","unloaded","Socket","window","PhxSocket","socket","onOpen","_this","isUnloaded","destroyAllViews","joinRootViews","addEventListener","e","bindingPrefix","views","viewLogger","activeElement","prevActive","silenced","bindTopLevelEvents","msgCallback","indexOf","readyState","_this2","connect","getBindingPrefix","disconnect","topic","params","channel","querySelectorAll","forEach","rootEl","_this3","joinView","parentView","getViewById","View","join","childEl","callback","closest","dropActiveElement","destroyViewById","destroy","cancel","_this4","removeEventListener","ownsElement","focus","getActiveElement","blur","bindClicks","bindForms","bindTargetable","keyup","keydown","type","phxEvent","phxTarget","pushKey","targetEl","pushEvent","events","event","browserEventName","_this5","on","binding","bindTarget","targetPhxEvent","owner","click","_this6","matches","parentElement","closestPhxBinding","preventDefault","_this7","disabled","submitForm","input","includes","DOM","isTextualInput","setActiveElement","pushInput","_this8","Browser","setCookie","cookie","getCookie","replace","RegExp","redirect","toURL","flash","location","disableForm","prefix","disableWith","classList","add","innerText","button","readOnly","restoreDisabledForm","remove","prev","discardError","field","getElementById","style","display","isPhxChild","patch","container","html","focused","liveSocket","selectionStart","selectionEnd","onNewChildAdded","mergeAttrs","mergeInputs","silenceEvents","restoreFocus","dispatchEvent","Event","getAttributeNames","setSelectionRange","parent","newChildrenAdded","gracefullyClosed","loader","nextElementSibling","session","_this9","getSession","loaderTimer","setTimeout","showLoader","bindChannel","hasGracefullyClosed","leave","receive","clearTimeout","middle","Math","floor","clientHeight","top","JSON","stringify","hideLoader","joinNewChildren","selector","_this10","Object","keys","_this11","update","to","token","onError","reason","onClose","onGracefulClose","_this12","data","onJoin","resp","onJoinError","displayError","onViewError","payload","onReply","_this13","pushWithReply","keyElement","inputEl","formEl","element","blurActiveElement","pushFormSubmit","_this14","restorePreviouslyActiveFocus"],"mappings":"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"}